[{"title":"P10656 题解","date":"2024-07-15T12:03:00.000Z","url":"/posts/P10656/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["扫描线","/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"]],"categories":[["undefined",""]],"content":"分析注意到一定存在包含 $x$ 中 $\\sum_{j&#x3D;1}^ix_j\\geq\\sum x$ 的第一个 $i$ 的最优方案。因为如果不包含，也就是 $x$ 和 $y$ 选择的两段都小于各自的 $\\sum$，那么把 $x$ 和 $y$ 中 $\\sum$ 大的那一个全选更优。对于 $y$ 同理。 也就是已经知道常数个位置中的某个会被包含在最优方案，枚举这个位置，假设在 THU 且为 $p$，那么对于 PKU 的 $[l,r]$ 区间，由于相同不能选，就把 THU 切成了很多段，每段都是能选的区间，而 $p$ 一定被选，所以就是 $p$ 所在的那段是答案。 根据 PKU 的选择区间 $[l,r]$ 可以求出 THU 的 选择区间 $[L,R]$。具体的，$i\\in[l,r]$，THU 的 $j$ 和 $i$ 相同 $j&gt;p$，$R\\leftarrow \\min(R,j-1)$， $j&gt;p$，$L\\leftarrow \\max(L,j+1)$， 那么对 PKU 做一个扫描线，需要支持前缀取 $\\max$ 和 $\\min$ 和求前缀最值。显然 $L,R$ 分别都是单调的，修改的都是一段区间，用线段树解决，递归到能修改才修改，复杂度为 $O(\\log n)$。 代码 闲话注意 PKU 和 THU 的第一个超过一半的位置都要算，刚好等于一半的话 $i+1$ 也要计算。记录方案可以只记录一半，另一半可以之后算出来。"},{"title":"祝 Aqours 九周年","date":"2024-07-05T05:23:00.000Z","url":"/posts/%E7%A5%9DAqours%E4%B9%9D%E5%91%A8%E5%B9%B4/","categories":[["undefined",""]],"content":"很高兴能认识你们，九周年了，好厉害呢。 虽然我并没有认识你们九年，大概是在二期动画和剧场版之间吧，我看到了善子夜羽，当时应该是觉得好可爱之类的，然后就第一次见到了 Aqours。 当时我还小，肯定也不懂这份感情，我也记不清了。只记得那之后石头剪刀布我都是出的善子剪刀手（就是出食指和无名指）。 不过之后 Aqours 的三次元部分我一直都没看过，可能是太二次元了接受三次元有点困难，直到幻日的夜羽之后。嘛看来幻夜也不是一无是处。 然后彻底喜欢上了 Aqours，喜欢上了全部。到今天都会后悔自己来的太晚了，之前喜欢的程度完全不够。 「いっぱい叫んだって足りない 君へのキモチは」 说到这里啊，就再说说之前的我干啥去了吧。 最开始，我接触这个世界的第一次，是 Kizuna Ai。 今天也正好是 Kizuna Ai 的生日呢，生日快乐。 但是最后还是离我而去了。 不过今天凌晨油管直播了，说了句 coming back，然后把视频全删了，之后就一直在放之前 pv 的字符画版。 不过我不抱希望，应该又是在消费死人烂炒。 然后玩一款两个字的游戏花了比较多的时间，有点后悔。 然后我一直会听 vocaloid，中 v 的话我很喜欢五维界质，特别是海伊。 但是也离我而去了。 真的不想再经历这种事了，何况现在 Aqours 完全是我的一切，别的都无所谓了啊。 「何か始まるってことは 終わりに繋がるだなんて」 「考えてもみなかった いや 考えたくなかったんだ」 现在我对我学 OI 的答案是，只要我能拿到牌子，我就能去看 Aqours 的 live 了，我就能有很多时间和她们在一起了。 如果没有的话，以我的环境，这是完全不可能的。 在这之后干嘛，我完全没想过，不过人都是短视的，没有人会想退休之后会干什么，没有人会想死掉之后又怎么样，想了也只会陷入虚无。 所以，这肯定也算是人生的正解之一。 本来是 Aqours 的九周年，我却扯了这么多废话。我这个人，满脑子都想着自己呢。 总之，我很开心，未来还请继续下去，我也会全力应援下去。final live 什么的，请绝对不要。"},{"title":"prufer 序列","date":"2024-02-01T16:00:00.000Z","url":"/posts/prufer%E5%BA%8F%E5%88%97/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["prufer 序列","/tags/prufer-%E5%BA%8F%E5%88%97/"]],"categories":[["undefined",""]],"content":"发现标题字打错了，然后改不了标题就重新发了一遍。 简介prufer 序列可以把一个结点带标号的树用 $n-2$ 个值域为 $[1,n]$ 的整数表示。 一棵树对应唯一的 prufer 序列，一个 prufer 序列对应唯一的树，二者为双射关系。 对树建立 prufer 序列每次找到编号最小的 __叶子结点__，把这个结点的父亲放入 prufer 序列的末尾，然后删掉这个叶子。重复 $n-2$ 次。 算法实现显然可以用堆实现，也可以线性构造。 维护一个 $p$ 表示最小的叶子结点，重复以下操作 删除 $p$。 如果父亲成为了叶子，且父亲的编号 $&lt;p$，删除父亲。不断重复 2 操作。 $p$ 自增直到找到新的叶子结点。 分析正确性，删除一个点新成为叶子的只会是父亲，如果父亲的编号 $&lt;p$，那么父亲是现在最小的叶子；如果父亲的编号 $&gt;p$，那么父亲会在之后被找到。 $p$ 只会遍历 $1$ 到 $n$，而删除的时候每条边只会遍历一次，所以复杂度为 $O(n)$。 代码 对 prufer 序列建立树prufer 序列里的点的出现次数 $+1$ 就是结点在树上的度数。 每次找到编号最小的 __度数为 $1$ 的结点__，与当前枚举的 prufer 序列的结点连边，然后这两个点度数 $-1$。 最后剩下两个度数为 $1$ 的点，其中一个是 $n$，将这两个点连边。 算法实现同理可以用堆实现，当然也可以线性构造。 现在 prufer 序列末尾添加结点 $n$，维护一个 $p$ 表示最小的 __度数为 $1$ 的结点__，重复以下操作 删除 $p$。 如果父亲度数变为 $1$ ，且父亲的编号 $&lt;p$，删除父亲。不断重复 2 操作。 $p$ 自增直到找到新的度数为 $1$ 的点。 代码 Cayley 公式完全图 $K_n$ 有 $n^{n-2}$ 棵生成树 证明可以使用 prufer 序列，purfer 序列有 $n^{n-2}$ 种（长度为 $n-2$ 每个位置可以是 $[1,n]$ 中的一个数），purfer 序列和生成树一一对应，所以有 $n^{n-2}$ 棵生成树。 类似的： $n$ 个点的无根树有 $n^{n-2}$ 种 $n$ 个点的有根树有 $n \\times n^{n-2}$ 种 $n$ 个点的无根树，每个点的度数为 $d_i$，有 $\\frac{(n-2)!}{\\prod^{n}{i-1}(d_i-1)!}$ 种，也为 $\\prod^{n}{i-1}C_{d_i-1}^{sum}$（sum 为还剩下的位置） 图连通方案数一个 $n$ 个点 $m$ 条边的带标号无向图有 $k$ 个连通块。我们希望添加 $k-1$ 条边使得整个图连通。求方案数。 感性理解一下，如果把每个连通块看成点，总方案数为 $n^{k-2}$。因为每个位置上填 $[1,n]$ 都有意义。 然后每个连通块还要和上一个连边，联通块内的每一个点都可能拿出来连，所以总方案数是 $n^{k-2}\\times \\prod^{k}_{i&#x3D;1}s_i$。 详细证明之后再说吧。 相关题目建 prufer 和建树：【模板】Prüfer 序列 Cayley 公式相关：[HNOI2004] 树的计数 图连通方案数：CF156D Clues"},{"title":"P9989 题解","date":"2023-12-23T16:00:00.000Z","url":"/posts/P9989/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["线段树","/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“笑って走っていく日も 泣きながら帰る日も この街と共に生きてる”——《街》 分析操作过后的数一定至少变为原来的 $\\frac{1}{2}$，所以问题变成了如何判断区间内是否会有数被修改。 可以维护 $\\text{lcm}$，如果 $v$ 不是 $\\text{lcm}$ 的倍数就说明存在数会被修改。 但是 $\\text{lcm}$ 可能会很大，但是如果 $\\text{lcm}&gt;v$ 那么 $v$ 一定不是 $\\text{lcm}$ 的倍数。 于是限制一个 $\\text{lcm}$ 的最大值，$\\text{lcm} \\leq V$ 时维护具体的值，否则只维护是否 $&gt; V$。 最多会被修改 $n \\log V$ 次，每次修改需要 $O(\\log n)$ 的时间去找到，因为辗转相除 $\\text{lcm}$ 单点修改的总复杂度为 $O(\\log V)$ ，总复杂度 $O(n \\log n \\log V)$。 代码"},{"title":"P5494 题解 & 平衡树合并","date":"2023-12-21T16:00:00.000Z","url":"/posts/P5494/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["平衡树","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["平衡树合并","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%90%88%E5%B9%B6/"]],"categories":[["undefined",""]],"content":"这是一篇平衡树合并题解，平衡树合并的复杂度 __并不是假的__，本题复杂度 $O(n \\log n)$，更通用的可以证明到 $O(\\log^2 n)$，比如支持序列 __全局加全局取膜__。  和上面的分析相同，但受个人水平所限可能有误，还希望多多包涵，注意下文 $n,V$ 不分。 平衡树比线段树适用性更广，常数也不大（未卡常 fhqtreap 用时 615ms）。 平衡树合并先不考虑分裂，单说合并。 现在要合并 $x,y$ 两棵树，选根节点堆值大的当根（假设是 $x$），把 $y$ 的子树按照 $x$ 的键值裂开（这里的裂开就是 treap 的 split），裂开的两瓣和 $x$ 的左右儿子递归下去合并。 明显是把小的树裂开更优，但是堆值大大概率就是树大的，下文也默认此情况（主要是带有随机的不会分析）。 其实这里存在一个合不合并相同结点的问题，其实是 要合并 的，因为 treap 的复杂度依赖于树和堆的唯一性，如果存在相同结点那么可能会失去性质（比如全部都一样，可以在不违反树和堆的情况下出来一条链），对于一般的 treap 不存在此问题，因为自带了一个插入时间的比较。 现在分析平衡树合并的复杂度，设第一棵树大小为 $a$，第二棵为 $b$，不难发现单次合并的复杂度 上界 为 $O(\\min(a,b)\\log(\\frac{\\max(a,b)}{\\min(a,b)}))$，大概是把小的树每个节点都拿去切割大的树，由于 finger search 所以切割复杂度为 $\\log(\\frac{\\max(a,b)}{\\min(a,b)})$。总复杂度为 $O(n \\log n)$。 为什么说是上界，因为在两颗树值域重合少的时候复杂度和最少不相交的值域段数 $k$ 有关，合并一次的复杂度为 $O(k \\log n)$。 本题的复杂度分析由于合并 $k$ 段值域不相交的复杂度为 $O(k \\log n)$，而一次 split 只会产生一段。问题是 $[l,x][x+1,y][y+1,r]$ 如果先合并 $[l,x][y+1,r]$ 再合并 $[x+1,y]$ 会产生额外的一次 $O(\\log n)$，但是合并次数等于分裂次数，所以总复杂度为 $O(n \\log n)$。 更通用的复杂度分析定义势能为 $\\varphi(T)&#x3D;\\sum\\log(v_{i+1}-v_i)$，也就是 $T$ 相邻的两个值的差的 $\\log$ 之和。 合并 $A$ 和 $B$，有 $k$ 段值域： $$\\begin{aligned}&amp;\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {&lt;-d_1-&gt;}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {&lt;–d_2–&gt;}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {&lt;–d_3–&gt;}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {&lt;—d_4—&gt;}\\&amp;A &#x3D; {{[–a_1–]}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {[-a_2-]}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {[–a_3–]}&amp;}\\&amp;B &#x3D; {\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ {[—b_1—]}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{[-b_2-]}&amp;}\\end{aligned}$$ 形如 ${[—–]}$ 的是一段值域，形如 ${&lt;–d_i–&gt;}$ 的是值域之间的距离且距离为 $d_i$。 合并后 $\\Delta\\varphi&#x3D;\\varphi(A)+\\varphi(B)-\\varphi(A\\cup B)$，有$$\\Delta\\varphi&#x3D;\\log(d_1+b_1+d_2)+\\log(d_2+a_2+d_3)+\\dots+\\log(d_{k-1}+a_{\\frac{k}{2}}+d_k)-(\\log d_1+\\dots+\\log d_k)$$ 前面的把 $\\log(+a_i+)$ 的放在一起就是根据定义算的 $\\varphi(A)$，后面的则是由于两段值域不交合并会产生新的势能，势能大小为 $\\log$ 值域的距离也就是 $\\log(d_i)$。 显然有$$\\Delta\\varphi\\geq\\log(d_1+d_2)+\\log(d_2+d_3)+\\dots+\\log(d_{k-1}+d_k)-(\\log d_1+\\dots+\\log d_k)$$ 因为 $\\log$ 函数是下凸的，可得 $\\log(\\frac{a+b}{2})\\geq \\frac{\\log a+\\log b}{2}$，把 $\\log$ 里的 $\\frac{1}{2}$ 拿出来可得$$\\log(a+b)\\geq 1+\\frac{\\log a+\\log b}{2}$$ 那么把 $\\log(d_{i-1}+d_i)$ 全部拆开，可得$$\\Delta\\varphi\\geq k-1-\\frac{d_1+d_k}{2}$$ 忽略常数可得$$\\Delta\\varphi\\geq k-O(\\log V)$$ 也就是说最多做 $n \\log V$ 次 split，总复杂度为 $O(n \\log V \\log n)$。 带有分裂的复杂度分析一次分裂会减少 $\\log V$ 的势能，split 是不增加势能的。 一次合并如果增加就至多增加 $\\log V$ 的势能（原因可以看上面的式子）。 那么最多就只有 $n\\log V$ 的势能，而 $\\Delta \\varphi$ 最大就是把这些势能都减少完，所以总复杂度为 $O(n \\log n \\log V)$。 代码 全局加全局取膜全局加不影响势能。 如果取模的过程中把树分成了 $k$ 段，合并后产生了至多 $(k-1) \\log v$ 的势能，但是 $v$ 也会变成 $\\dfrac{v}{k}$。把 $\\log v$ 提到外面来，显然每轮最劣的 $k$ 都是一样的，因为这是一个递归的问题。原问题变成了 $k$ 使得 $k\\log_k n$ 最大。解得最小值取 $e$，最大值为 $n$。所以增加的势能最大为 $n \\log v$。 所以总复杂度为 $O(n \\log n\\log v)$。 通用性确实这东西很能拓展，只要不咋影响势能都可以把合并当作基本操作，比如加、除、取膜、开根、翻转。 其实全局取膜作用与值域区间也是对的，值域区间完全可以把它当成两个独立的序列分别操作后再 merge 起来，分别操作也就是 $(n-m)\\log v+m \\log v&#x3D; n\\log v$，完全不影响。最后只是常数段的 merge 新增的 $\\log v$ 的势能。所以只会增加总共 $n \\log v$ 的势能。别的同理。"},{"title":"Blog 索引","date":"2023-12-20T16:00:00.000Z","url":"/posts/Blog%E7%B4%A2%E5%BC%95/","tags":[["索引","/tags/%E7%B4%A2%E5%BC%95/"]],"categories":[["undefined",""]],"content":"君のこころは輝いてるかい？ $\\LARGE \\mathscr Part\\ \\rm A\\quad\\LARGE\\textbf{知识}$ 基本都是我乱写的。 为了便于挑选文章，下面有几种标记 ： $\\color{blue}\\large\\circledcirc$ 意为 内容完善 $\\color{red}\\large\\circledcirc$ 意为 内容简略&#x2F;尚不完整 $\\color{purple}\\large\\circleddash$ 意为 施工中&#x2F;内容不严谨 $\\checkmark$ 意为 推荐 $\\dag$ 意为 过时&#x2F;可能存在错误 数据结构 可持久化线段树 $\\color{red}\\large\\circledcirc$ 整体二分 $\\color{red}\\large\\circledcirc$ $\\dag$ dsu on tree$\\color{red}\\large\\circledcirc$ 平衡树合并$\\color{blue}\\large\\circledcirc$ $\\checkmark$ 数学 异或线性基 $\\color{blue}\\large\\circledcirc$ fmt&amp;fwt 图论 联通性相关 $\\color{blue}\\large\\circledcirc$ 网络流常见建模 $\\color{purple}\\large\\circleddash$ 圆方树 $\\color{red}\\large\\circledcirc$ prufer 序 $\\color{blue}\\large\\circledcirc$ 动态规划 杂 高维前缀和&#x2F;sosdp $\\color{blue}\\large\\circledcirc$ 切比雪夫距离与曼哈顿距离 $\\color{blue}\\large\\circledcirc$ $\\checkmark$ $\\LARGE \\mathscr Part\\ \\rm B\\quad\\LARGE\\textbf{记录}$ 等我写了 200 道就发出来。 $\\LARGE \\mathscr Part\\ \\rm C\\quad\\LARGE\\textbf{杂}$ 也许是文化课相关内容，或者是我感兴趣的一些研究，再者就是杂谈。"},{"title":"切比雪夫距离与曼哈顿距离","date":"2023-12-11T16:00:00.000Z","url":"/posts/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["曼哈顿&切比雪夫","/tags/%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB/"]],"categories":[["undefined",""]],"content":"内含高维曼哈顿-切比雪夫转换。 定义曼哈顿距离：$|x_1-x_2|+|y_1-y_2|$ 切比雪夫距离：$\\max(|x_1-x_2|,|y_1-y_2|)$ 更多距离欧几里得距离：$\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ $L_m$ 距离：$(|x_1-x_2|^m+|y_1-y_2|^m)^{\\frac{1}{m}}$ $n$ 维欧几里得距离：$\\sqrt{\\sum_{i&#x3D;1}^n(d_{i1}-d_{i2})^2}$ $n$ 维曼哈顿距离：$\\sum_{i&#x3D;1}^n|d_{i1}-d_{i2}|$ $n$ 维切比雪夫：$\\max_{i&#x3D;1}^n|d_{i1}-d_{i2}|$ 转换曼哈顿转切比雪夫：$(x,y)\\rightarrow(x+y,x-y)$ 切比雪夫转曼哈顿：$(x,y)\\rightarrow(\\frac{x+y}{2},\\frac{x-y}{2})$ 证明证明可以用几何，因为曼哈顿坐标系是通过切比雪夫坐标系旋转 $45^\\circ$ 后，再缩小到原来的一半得到的。 或者纯代数，$x\\leq y$ 时 $|x-y|&#x3D;x-y$，$x&lt;y$ 时 $|x-y|&gt;x-y$，转换成 $(x+y,x-y)$ 之后 $\\max(|x_1-x_2|,|y_1-y_2|)$ 一定是原来的 $|x_1-x_2|+|y_1-y_2|$ 都取到绝对值的时候，也就是曼哈顿距离，而 $\\max(|x_1-x_2|,|y_1-y_2|)$ 就是切比雪夫距离。 其实是转换成 $(x,y),(-x,y),(x,-y),(-x,-y)$，因为切比雪夫本身有绝对值所以正负效果是一样的，去掉重复一半的就是上面的式子。 切比雪夫转曼哈顿其实就是解 $\\begin{cases}x+y&#x3D;a\\cr x-y&#x3D;b\\end{cases}$ 的方程。 高维切比雪夫和曼哈顿通过上面的证明可以得到，$k$ 维曼哈顿可以转换为 $2^{k-1}$ 维的切比雪夫。 也就是指定每一位取正还是取负，在去掉重复的 $\\frac{1}{2}$。 但是高维切比雪夫却不一定都能转换为曼哈顿，因为本质这个转换是解方程，拿四维切比雪夫 $(a,b,c,d)$ 举例 $$\\begin{cases}x+y+z&#x3D;a\\cr-x+y+z&#x3D;b\\crx-y+z&#x3D;c\\crx+y-z&#x3D;d\\end{cases}$$ 这个方程需要满足 $a&#x3D;b+c+d$ 才能有解，有解情况下 $$\\begin{cases}x&#x3D;\\frac{a-b}{2}\\cry&#x3D;\\frac{a-c}{2}\\crz&#x3D;\\frac{a-d}{2}\\end{cases}$$ 而切比雪夫不是 $2^k$ 维的情况下我们可以升维成 $2^k$ 维，这个时候补 $0$ 也有可能使得方程一定有解。 比如求$$\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^{i-1}\\max(a_i-a_j,b_i-b_j,c_i-c_j)-\\min(a_i-a_j,b_i-b_j,c_i-c_j)$$ 可以直接 min-max 容斥，但是跑的慢 推式子 $$\\begin{aligned}&amp;\\max(a_i-a_j,b_i-b_j,c_i-c_j)-\\min(a_i-a_j,b_i-b_j,c_i-c_j)\\cr&#x3D;&amp;\\max(|b_i-b_j-(a_i-a_j)|,|c_i-c_j-(b_i-b_j)|,|a_i-a_j-(c_i-c_j)|)\\cr&#x3D;&amp;max(|(b_i-a_j)+(b_j-a_j)|,|(c_i-b_i)+(c_j-b_j)|,|(a_i-c_i)+(a_j-c_j|))\\end{aligned}$$ 这明显是一个三维切比雪夫，给他升成四维，令 $a&#x3D;0$，刚好满足 $a&#x3D;b+c+d$，所以原式为 $$\\frac{1}{2}\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^{i-1}|b_i-a_i|+|c_i-b_i|+|a_i-c_i|$$ 这个直接排序就能求了。 补充其实不把重复的去掉，保留 $2^k$ 维，这样就不用取 $\\text{abs}$ 了，能有比切比雪夫更好的性质。"},{"title":"P2120 题解","date":"2023-11-04T16:00:00.000Z","url":"/posts/P2120/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["斜率优化","/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"],["李超树","/tags/%E6%9D%8E%E8%B6%85%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“生きてく意味があると感じるよ…確かに！”——《Nameless Love Song》 分析首先写个 $n^2$ dp 转移 $$\\begin{aligned}f_i&amp;&#x3D;\\min_{j&#x3D;1}^{i-1}(f_j+\\sum_{k&#x3D;j+1}^i(x_i-x_k)p_k)+c_i\\ &amp;&#x3D;\\min_{j&#x3D;1}^{i-1}(f_j+x_i\\sum_{k&#x3D;j+1}^ip_k-\\sum_{k&#x3D;j+1}^ix_kp_k)+c_i\\ &amp;&#x3D;\\min_{j&#x3D;1}^{i-1}(-x_i\\sum_{k&#x3D;1}^jp_k+f_j+\\sum_{k&#x3D;1}^jx_kp_k)+x_i\\sum_{k&#x3D;1}^ip_k-\\sum_{k&#x3D;1}^ix_kp_k+c_i\\end{aligned}$$ 然后 $\\min$ 里面的像一次函数，直接上李超树。 一些细节要特判末尾连续的 $p_i&#x3D;0$，以及第 $8$ 个点卡李超树，别的 hack 倒是不用管。 代码"},{"title":"聊聊 dsu on tree","date":"2023-10-30T16:00:00.000Z","url":"/posts/dsu_on_tree/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["dsu on tree","/tags/dsu-on-tree/"]],"categories":[["undefined",""]],"content":"契约签订完毕，接下来要认真起来了。 简介对于子树查询类问题，大多可以 dfs 序然后上数据结构，不行就树上莫队。 一个方法是 dsu on tree，是一个好写的复杂度 $O(n \\log n)$ 离线算法。 过程考虑启发式，对于每个节点找出重子树，然后 递归询问所有轻子树（询问后删除贡献） 递归询问重子树（保留贡献） 加入所有轻子树内节点的贡献 证明对于复杂度，总操作次数为 $n+\\sum$ 轻子树大小。类似于树链剖分，每个点被多操作一次就代表成为了一次轻子树，而轻子树的父亲的子树大小至少为轻子树的 $2$ 倍，所以每个点至多被操作 $\\log$ 次。 性质加入重儿子之前的全局所有贡献都是被删掉了的。 这意味着 dsu on tree 和 $O(n^2)$ 去统计在贡献处理上没有任何区别，也意味着回滚莫队能做的都能做。 题目CF600E Lomsat gelral直接 dsu on tree，求众数和可以正常做，撤销的时候不仅要把计数的数组撤销，还要把最多出现次数和众数和撤销，后者也好办，操作前记录一个撤销的时候直接赋值就好了。 CF741D Arpa’s letter-marked tr…排序后能是回文串要么每个字符都是偶数，或者只有一个为奇数。 字符只有 $22$ 个，可以记录某些字符出现奇数的最长长度，然后类似于点分治去统计。 把这个过程按照 dsu on tree 做就好了。 CF1767F Two Subtrees如果只询问一个子树，那么就是 dsu on tree 板子。 考虑把 __dsu on tree 序列化__，先加入轻子树，再加入重子树，再加入根。 当扫描这个序列的所有子树时，轻子树的移动后会直接被删掉，重子树移动后再查询根，重子树会被保留同时加入所有轻子树，扫描的复杂度为 $O(n \\log n)$。 直接在这个序列上莫队，区间的左右端点为询问的两颗子树。 子树询问的区间移动就如果目标区间当前区间无交就当前区间删除然后暴力加入目标区间，否则就就正常移动左右端点。"},{"title":"真·浅谈线性基","date":"2023-09-18T16:00:00.000Z","url":"/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["线性基","/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"]],"categories":[["undefined",""]],"content":"或许是该努努力了呢，快要来不及了。 异或线性基简单来说，线性基是一个数的集合，每个序列都拥有一个线性基，线性基中的若干个数异或起来原序列中的任意一个数。 重要性质： 原序列中的任意一个数都能通过线性基中的若干个数异或得到。 线性基内任意数异或和不为 $0$。 一个序列的所有线性基大小相同。 别的性质： 由 $n$ 个数组成的大小为 $s$ 的线性基，能构成 $2^s$ 种不同的数，每个数出现 $2^{n-s}$ 次。 基本操作插入 求异或最大值 求异或最小值如果是序列内部最小的异或值，那么如果有元素不能被插入线性基，最小值为 $0$，否则为线性基中最小的元素。 如果是丢一个数进去的话，类似于求异或最大值做就行了。 查询存在性能插入进去就是不存在，否则就是存在。 求 $k$ 小值先预处理，对于线性基 $d$，如果 $d_i(0 \\leq i &lt; n)$ 的二进制位 $j(0 \\leq j &lt; i)$ 为 $i$，$d_i$ 异或上 $d_j$。 线性基求并把一个线性基的全部元素插入另一个就行。 例题P3857 [TJOI2008] 彩灯一个序列若干数异或得到的集合和这个序列的线性基异或得到的集合是一样的。 由于线性基性质 2，一个大小为 $s$ 的线性基能异或得到 $2^s$ 个数。 那么算出这个序列的线性基，答案就为 $2^s$。 P4570 [BJWC2011] 元素因为线性基性质 2，线性基内任意数异或和不为 $0$，考虑线性基。 因为线性基性质 3，无论顺序能放进去的总个数是不变的，贪心的先放贡献大的就行。 P5556 圣剑护符距离 $&gt;30$ 的路径是一定存在一个子集异或值为 $0$ 的，因为这样线性基一定会被插满。 那么对于 $\\leq 30$ 的暴力用线性基判断，用树剖和线段树维护 lca 和修改。 P4151 [WC2011] 最大XOR和路径走的路径一定是一条链然后走到了一些别的地方又回来。 一个路径走两遍就没了贡献，那么有贡献的一定是走到了环，并且贡献为环本身，因为走去环回来这条路径被走了两遍。 这样的话所有的环都能自由选择，把所有的小环的异或值加入线性基（大环相当于小环的异或值），就相当于自由选择所有的环。 考虑选择走的 $1\\rightarrow n$ 链，链可以随便选，因为如果有多条链，一定都构成了环，那么选择构成的那个环就相当于选择了另一条链。 把选择的链的异或值去线性基里跑最大异或值就行了。CF845G 就是跑最小值。 P5607 [Ynoi2013] 无力回天 NOI2017首先这是个数据结构套线性基础，考虑线段树，但是修改是区间修改线性基不太好做。 差分，$b_i&#x3D;a_i\\ \\text{xor}\\ a_i$，把区间修改变为单点修改。 $a_i$ 可以用 $b_1\\ \\text{xor}\\ b_2 \\dots \\ \\text{xor}\\ b_i$ 表示出来，那么 $a_l\\dots a_r$ 的所以子集异或都能用 $a_l\\ b_{l+1} \\ldots b_r$ 表示出来。 用线段树维护 $b$ 的线性基，同时用树状数组维护 $b$ 的前缀异或和来求 $a_l$。 询问就求出 $b_{l+1}\\dots b_r$ 插入 $a_l$ 然后求异或最大值，特判 $l&#x3D;r$。 线性基合并的复杂度为 $O(\\log^2V)$，所以总复杂度为 $O(n \\log n \\log^2 V)$。 P3292 [SCOI2016] 幸运数字因为是算异或最大值，求的是树上路径线性基，倍增直接做是 $\\log m \\log^2 V$ 的。 发现 __线性基重复部分没有贡献__，类似于 $\\max,\\gcd$ 这些，然后直接用 st 表那种做法做。 具体的，先倍增预处理线性基。对于询问找到 lca 之后拆成 $x \\rightarrow lca$ 和 $y \\rightarrow lca$ 两条链。对于一条链 $x\\rightarrow y$，倍增找到 $u$ 使得 $dep_u-dep_y+1&#x3D;2^{\\lfloor \\log({dep_x-dep_y+1}) \\rfloor-1}$，复杂度瓶颈在于合并线性基的 $O(\\log^V)$，找 $u$ 的 $O(\\log n)$ 无所谓。 复杂度为 $O(n \\log^2 V+n \\log^3 n)$，$n$ 比 $V$ 小足以通过。 P4869 albus就是要第一个出场由 $n$ 个数组成的大小为 $s$ 的线性基，能构成 $2^s$ 种不同的数，每个数出现 $2^{n-s}$ 次。 查询排名就是从低位到高位看，如果第 $i$ 位存在线性基且查询的数 $q$ 二进制的第 $i$ 为 $1$，记 $c$ 为 $[0,i)$ 的线性基个数，排名加上 $2^c$。 因为是第 $i$ 位存在线性基，相当于强制选了第 $i$ 位，这样就不会算重。 不会证明，之后再补吧。"},{"title":"真·浅谈高维前缀和/sosdp","date":"2023-09-18T16:00:00.000Z","url":"/posts/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["高维前缀和","/tags/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"]],"categories":[["undefined",""]],"content":"夜空是否全然知晓？ 高维前缀和&#x2F;sosdp计算高维前缀和可以不用容斥，而是对每一维分别做前缀和，复杂度为 $O(kn)$，其中 $k$ 是维度。 对于子集求和问题，相当于二进制下的 $1$ 可以选 $0$ 或 $1$，$0$ 只能选 $0$，类似于一个高维的前缀和问题。 那么就可以在 $O(n 2^n)$ 的复杂度之内求出类似于子集和的问题。 题目ARC100E Or Plus Max$i \\in k,j \\in k$ 是 $i | j &#x3D; k$ 的必要条件，是 $i|j&lt;&#x3D;k$ 的充分条件。 先算出 $&#x3D;k$ 的答案，在求个前缀最小值就算出了 $\\leq k$ 的答案，然后也满足了充要。 然后就是求子集最大值和次大值，高维前缀和解决。 CF1208F Bits And Pieces考虑枚举一个 $i$，然后 $d_i|(d_j &amp; d_k)&#x3D;d_i+(d_i &amp; d_j &amp; d_k)$。 要使得 $d_i &amp; d_j &amp; d_k$ 更大，从高位到低位贪心的看能不能是 $1$。 假设当前选择的为 $s$，首先 $d_i \\in s$，然后存在 $j,k$ 使得 $i &lt; j &lt; k$ 并且 $d_j \\in s,d_k \\in s$。 相当于求一个超集的最大值和次大值，这种类似子集和的问题可以用高维前缀和解决。 P6442 [COCI2011-2012#6] KOŠARE设选择的集合为 $s$，$f_s$ 为 $\\in s$ 的个数，那么集合 $\\in s$ 的个数为 $2^{f_s}-1$。 $f_s$ 可以用高维前缀和算，然后按照 $1$ 的个数容斥就行了。 也可以再跑一遍差分。 CF449D Jzzhu and Numbers和上一道类似，不过不是跑子集是跑超集。 然后跑容斥或者差分。"},{"title":"整体二分浅谈","date":"2023-08-31T16:00:00.000Z","url":"/posts/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["整体二分","/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"]],"categories":[["undefined",""]],"content":"浅浅的总结一下简单情况。 适用范围可以使用整体二分解决的题目需要满足以下性质： 询问的答案具有可二分性 修改对判定答案的贡献互相独立，修改之间互不影响效果 修改如果对判定答案有贡献，则贡献为一确定的与判定标准无关的值 贡献满足交换律，结合律，具有可加性 题目允许使用离线算法 许昊然《浅谈数据结构题几个非经典解法》 一般来说适用于二分时每次 check 都要预处理，同时预处理代价较大的情况。 把所有询问一起二分，对于一个 check 就只需要预处理一次。 特殊情况的处理查询比如区间第 $k$ 小，就和平衡树上类似的，如果不在 $[l,mid]$ 里的，$k$ 要减去 $[l,mid]$ 小于它的个数。 修改把修改和询问都视为操作（修改要满足上面的性质）。 比如带修改区间第 k 大，修改为把 $x$ 位置上的数改成 $y$，当 $mid\\geq y$ 时用树状数组在 $x$ 这里 $-1$ 表示删除。 二维化把初始的的都视作修改就能轻松处理。 类似 P1527 [国家集训队] 矩阵乘法。 优化相比每次都撤销 $[l,mid]$ 内的所有预处理，维护一个 $p$ 表示 $[1,p]$ 已经被预处理，然后类似莫队的区间移动去把 $p$ 移动到 $mid$，这样加入和撤销的次数会少一半。 然后有些预处理操作不用撤销可以换成区间操作，就能少一个 $\\log$。"},{"title":"P4732 题解","date":"2023-07-09T16:00:00.000Z","url":"/posts/P4732/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["可持久化线段树","/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“这样的我会被谁拯救吗 你发现了吧” —— 《月光掌》 分析设第 $i$ 次撤销操作要撤销的是 $j$，那么 $i$ 到 $j$ 的操作中不存在优先级比 $j$ 小的，所以 $j$ 到 $i$ 的操作不会在没撤销 $i$ 的情况下被撤销。 考虑可持久化线段树，维护操作的优先级，撤销操作 $i$ 直接继承 $j-1$ 的线段树，查询 $j$ 直接线段树上二分。 代码"},{"title":"网络流常见建模","date":"2023-07-03T16:00:00.000Z","url":"/posts/joi2015ho_d/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"你眼中倒映的世界 一瞬永远 —— 《梦语》 分析首先答案有单调性，考虑二分。 然后每次留下来的构成一颗三叉树，父亲是儿子的中位数，考虑树形 dp。 上很经典的中位数套路，设二分的值为 $v$，$\\geq v$ 的 $g_v$ 为 $1$，$&lt; v$ 的 $g_v$为 $-1$。 如果儿子的值之和 $&gt;0$ 那么父亲就 $\\geq v$。 考虑设 $f_u$ 为 $g_u &gt; 0$ 时最小的子树的叶子中 $\\geq v$ 的个数。 转移为 $f_u &#x3D; \\sum f_v -\\max f_v$，因为如果 $g_u &gt; 0$ 必须有两个及以上的 $g_v&#x3D;1$，多了没用所以是选择最小的的两个 $f_v$。 如果 $f_{root} \\leq$ 序列中 $\\leq v$ 的个数就是可行的。 代码"},{"title":"网络流常见建模","date":"2023-06-29T16:00:00.000Z","url":"/posts/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E8%A7%81%E5%BB%BA%E6%A8%A1/","tags":[["网络流","/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"],["学习笔记笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"本文主要讲建图方法，定义和证明内容较少。 正好网络流二十四题做完了整理下。 目录 网络流模型 最大流最小割 最小割树 平面图最小割 费用流 SSP 算法 有负圈的费用流 上下界建模 无源汇上下界可行流 有源汇上下界可行流 有源汇上下界最大&#x2F;小流 经典问题 二分图 二分图最大匹配 二分图最小点覆盖 二分图最大独立集 路径覆盖与链覆盖 DAG 最小路径覆盖 DAG 最小链覆盖 DAG 最长反链 最大权闭合子图 最大密度子图 各种建模 拆点 分层图 最大流相关 最小割相关 最小割离散变量模型（切糕） 费用流相关 杂 区间问题常见建模 网络流模型最大流最小割最大流 &#x3D; 最小割是网络流中的重要结论，运用最大流和最小割可以解决一些复杂度划分问题。 最小割树主要解决 多次询问 无向图两点之间的最小割的问题。 一个 $N$ 个点的图上，两点之间只有 $N$ 中本质不同的最小割。因此一定存在一棵树，满足树上两点的最小割等于原图上两点的最小割。我们把这样的树称之为 __最小割树__。 Gomory-Hu 算法考虑分治，在所有点中任取两个作为源汇点求出最小割，划分成两个互不连通的割集。对这两个点连边，边权为求出来的最小割。然后对与两个割集递归下去做。同时每次的最小割都是对于全局跑的， 询问两个点之间的最小割，就是求这两个点在最小割树上的路径中最小的边。可以用倍增实现。 参考&amp;例题P4897【模板】最小割树 证明见 Eznibuil 博客 平面图最小割平面图最小割 &#x3D; 对偶图最短路。 平面图如果图 $G$ 能画在平面 $S$ 上，且除顶点外无边相交，则称 $G$ 可平面嵌入 $S$，$G$ 可称为可平面图或平面图，画出的没有边相交的图称为 $G$ 的平面表示或平面嵌入。 对偶图设 $G$ 是平面图的某一个平面嵌入，构造图 $G^*$： 在 $G$ 的每个面放 $R_i$ 置 $G^*$ 的一个顶点 $v^*$。 设 $e$ 为 $G$ 的一条边，若 $e$ 在 $G$ 的面 $R_i$ 和 $R_j$ 的公共边上，做 $G^*$ 的边 $e^*$ 与 $e$ 相交，且 $e^*$ 连接 $G^*$ 的顶点 $v_i^*,v_j^*$，即 $e^*&#x3D;(v_i^*,v_j^*)$，$e^*$ 不与其他边相交。若 $e$ 为 $G$ 中的桥且在 $R_i$ 的边界上，则 $e^*$ 是以 $R_i$ 中顶点 $v_i^*$ 为端点的环，即 $e^*&#x3D;(v_i^*,v_j^*)$。 形象化的说，对偶图就是把平面图的每条边 __旋转了 $90$ 度__。 对偶图的性质 $G^*$ 为平面图，且为平面嵌入。 $G$ 中自环对应 $G^*$ 桥，$G$ 中桥对应 $G^*$ 自环。 $G^*$ 是连通的。 若 $G$ 的面 $R_i,R_j$ 的边界上至少有两条公共边，则关联$v_i^*,v_j^*$ 的边有平行边，$G^*$ 多半是多重图。 同构的图的对偶图不一定是同构的。 $G^{**}$ 与 $G$ 同构当且仅当 $G$ 是连通图。 平面图最小割 &#x3D; 对偶图最短路 参考&amp;例题P2046 [NOI2010] 海拔 oi-wiki 费用流可以解决一些需要最优化的问题。 SSP 算法每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。 如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。 设该网络的最大流为 $f$ ，则最坏时间复杂度为 $O(nmf)$。SSP 算法是 伪多项式时间 的。 实现只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。 参考&amp;例题P7173【模板】最小费用最大流 oi-wiki 有负圈的费用流由于存在最短路，所以费用流算法不能直接做费用有负圈的图。 消圈算法本身就有消除负圈的过程，但是效率低下。 对于网络中的负费用边 $(x,y)$，强制满流。然后加入 $(y,x)$，费用为原来费用的相反数，用于退流。 跑有源汇上下界最小费用最大流即可。 例题P7173 【模板】有负圈的费用流 上下界建模上下界网络流本质是给流量网络的每一条边设置了流量上界 $c(u,v)$ 和流量下界 $b(u,v)$ 。也就是说，一种可行的流必须满足 $b(u,v) \\leq f(u,v) \\leq c(u,v)$ 。同时必须满足除了源点和汇点之外的其余点流量平衡。 无源汇上下界可行流先假设每条边已经流了 $b(u,v)$ 的流量，在新图中加入流量为 $c(u,v)-b(u,v)$ 的边。 最大流需要满足初始流量平衡条件，但是构造出来的初始流很有可能不满足初始流量平衡。 假设一个点初始流入流量减初始流出流量为 $M$，同时建立附加源点 $S’$ 和附加汇点 $T’$： $M&#x3D;0$ 流量平衡 $M&gt;0$ 入流量大，$S$ 向其连流量为 $M$ 的边 $M&lt;0$ 出流量大，其向 $T$ 连流量为 $-M$ 的边 如果附加边满流，说明这一个点的流量平衡条件可以满足，否则这个点的流量平衡条件不满足。 在建图完毕之后跑 $S’$ 到 $T’$ 的最大流，若 $S’$ 连出去的边全部满流，则存在可行流，否则不存在。 有源汇上下界可行流设源点为 $s$，汇点为 $t$。添加一条 $t$ 到 $s$ 的上界为 $\\infty$ 下界为 $0$ 的边。 注意这里的源汇点已被视为普通点，与超级源汇点不同的。 有源汇上下界最大&#x2F;小流最大流先找到可行流，然后删去附加边 $t \\rightarrow s$，在残留网络上跑最大流。 将可行流流量和最大流流量相加即为答案。 最小流先在没加附加边的网络上跑最大流，再对残量网络加入附加边 $t \\rightarrow s$，最小流即为附加边的流量。 例题 最大流：P5192 Zoj3229 Shoot the Bullet|东方文花帖|【模板】有源汇上下界最大流 最小流：P4843 清理雪道 经典问题二分图二分图最大匹配将源点连上左边所有点，右边所有点连上汇点，容量dou为 $1$。原来的每条边从左往右连边，容量也皆为 $1$，最大流即最大匹配。 如果用 Dinic 算法求最大流，时间复杂度为 $\\sqrt{n}m$。 二分图最小点覆盖 最小点覆盖：选最少的点，满足每条边至少有一个端点被选。 König 定理：最小点覆盖 $&#x3D;$ 最大匹配。 二分图最大独立集 最大独立集：选最多的点，满足两两之间没有边相连。 二分图中，最大独立集 $&#x3D;n\\ -$ 最小点覆盖。 因为在最小点覆盖中，任意一条边都被至少选了一个顶点，所以对于其点集的补集，任意一条边都被至多选了一个顶点，所以不存在边连接两个点集中的点，且该点集最大。 参考oiwiki 路径覆盖与链覆盖DAG 最小路径覆盖 DAG 最小路径覆盖：尽可能少的不相交的路径（链）覆盖掉所有节点。 考虑把单个结点也看成一条路径，相邻结点合并路径条数就会减少，所以要最大化可以合并的个数。 因为是最大化合并，考虑 二分图最大匹配 ，把每个点拆成 $u’$ 和 $u’’$，原图上边 $u \\rightarrow v$ 就在新图上连一条 $u’ \\rightarrow v’’$，跑二分图最大匹配，就是最大的可合并的点数，总点数减去大的可合并的点数就是最小路径覆盖。 DAG 最小链覆盖 DAG 最小链覆盖：尽可能少的的路径（链）覆盖掉所有节点，可以相交。 最小链覆盖与最小路径覆盖非常相近，考虑将最小链覆盖转化为最小路径覆盖。 用 Floyd 求出原图的传递闭包，直接在传递闭包上跑最小路径覆盖即可。 传递闭包：这里简单理解为对于所有联通的点对连边的新图 DAG 最长反链 反链：点的集合满足任意 $x,y$，$x,y$ 互不连通 Dilworth 定理：最小链覆盖大小 $&#x3D;$ 最长反链长度。 最大权闭合子图 闭合子图：对于点集 $S$，任意 $u\\in S$，$u$ 的出边的另一个点也属于 $S$。 最大权闭合子图：点权和最大的闭合子图。 最大权闭合子图 $&#x3D;$ 正权和 $-$ 最小割 例题P2762 太空飞行计划问题 P3410 拍照 最大密度子图 最大密度子图：闭合子图使得 $\\frac{|E|}{|V|}$ 最大。 一般情况下，我们使用 01 分数规划 解决最大密度子图问题。 二分比值 $v$，建图 $S$ 到 $i$ 连容量为 $m$ 的边 $i$ 到 $T$ 连容量为 $m+2*v-deg_i$ 的边 原图上的边容量为 $1$ 如果流量 $&#x3D;n\\times m$ 就存在密度为 $\\geq v$ 的子图。 一般来说二分的 $eps$ 不能设太小，不然无法判断边是否有流量。 例题UVA1389 Hard Life 各种建模拆点本质上是将点的限制转化为边的限制。"},{"title":"APIO2023 赛博乐园","date":"2023-05-26T16:00:00.000Z","url":"/posts/APIO2023/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["最短路","/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"]],"categories":[["undefined",""]],"content":"“并没有 不一样 为何感到悲伤” —— 《尘降》 分析首先把图反着跑，这样总通行时间除以 $2$ 就变成了后续时间都除以 $2$，当前总通过时间为 $0$ 就变成了后续时间都为 $0$。 然后把一个点拆开成 $K+2$ 个，第 $i$ 个代表经过 $i$ 次除以二操作的点，最后一个代表经过清零操作的点，然后跑最短路。 注意一下 $H$ 不能多次经过和不能达到为 $-1$，这样就有 $97$ 分了。 发现除以二操作做 $\\log_2 \\frac{10^5\\times10^9}{10^{-6}}$ 次就会变成可以忽略的值，所以 $K$ 和 $70$ 取小的那一个就行。 代码 闲话考试的时候用的是 $50$ 过了，死过以内。"},{"title":"ABC241G 题解","date":"2023-05-23T16:00:00.000Z","url":"/posts/AT_abc241_g/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["网络流","/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"],["最大流","/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"]],"categories":[["undefined",""]],"content":"分析枚举第一名，假设以后的比赛该名玩家都获胜，然后判定是否合法。 数据范围很网络流，考虑最大流，流量代表得分，然后是建图： 源点和每场比赛连容量为 $1$ 的边 比赛如果有胜负就向胜者连边，否则就向参与比赛的两个人连边 设第一名的得分为 $w$，第一名向汇点连容量为 $w$ 的边，其余的人得分不能超过第一名，所以其余的人向汇点连容量为 $w-1$ 的边 由于总场次为 $\\frac{n(n+1)}{2}$，如果最大流为 $\\frac{n(n+1)}{2}$ 就说明每场比赛都分出了胜负，这种情况合法。 代码"},{"title":"APIO2023 线上游记","date":"2023-05-23T16:00:00.000Z","url":"/posts/P4698/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"“请告诉我为何心不停的跳动 这颗心究竟装着什么” —— 《人偶之梦》 分析注意到 $p_i&lt;p_j$ 则 $c_i\\leq c_j$，存在偏序关系。 一个贪心的想法是，按照订单的 $v$ 从大到小，每次找到大于 $d$ 的最小的 $p$ 住进去。 但是如果房间已经被占用，就住进大于 $d$ 的 $p$ 最小的没有被占用的房间，而不是把占用清除。 考虑这样为什么是对的，设占用房间的为 $i$，要住进去的为 $j$。 如果 $i,j$ 都要入住，答案无影响。 如果 $i,j$ 只有一个要入住，因为 $v_i&gt;v_j$，所以 $i$ 肯定比 $j$ 更优，$j$ 必定不会被选到（就选选的不是最优的房间也不影响）。 现在问题变成了，找到大于 $d$ 的 $p$ 最小的没有被占用的房间，然后把这个房间删除，multiset 可以解决（注意房间可重，set 不可重）。 代码 闲话$p_i&lt;p_j$ 则 $c_i\\leq c_j$ 放在题面更合理吧，放在数据范围有点抽象。"},{"title":"APIO2023 线上游记","date":"2023-05-22T16:00:00.000Z","url":"/posts/apio2023%E7%BA%BF%E4%B8%8A%E6%B8%B8%E8%AE%B0/","tags":[["游记","/tags/%E6%B8%B8%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"day-?报名被报成线上了，寄寄寄。 day-?P 和我的年龄给了我可能今年唯一能看的成绩。 day 0麦会炸，是那种嘶吼声的回音的感觉。 字符串，感觉自己没学过了。 直播能很好看到旷课人数，很震撼，签到更震撼。 同时知道了 __线上没监考__。 线下看起来好好玩，你们发在 LA 群里的自拍是在同情我吗，你们玩音游的真多，我也想玩，你们发在 LA 里的 kfc 是在同情我吗，华山饭店好厉害，你们带带我行不。 然后一遍听中v曲一边改之前 apio 的题，自信啊，那不得保底 Ag。 day 1T1 板到不行，半小时就写好了。 这是什么，cms，刷新一下。 这是什么，OJ，交一下。 啥情况就不说了，结束前半小时才知道我 T1 过了（一个小时 debug 一次），我 K 和 50 取 min 还能过很厉害啊，想不通。 T2 不会，32 分不说了，$a_i\\leq 3$ 的随便搞几下就过了（当然也是在考试后知道的）。$7$ 分的暴力写挂了（同上）。 T3 电路，可是我去的 P，加法器没写出来。 能不能下次复刻光追，求求你了。 结束了。 day 2听到了 200 一车，早就知道了，我考的相当烂，我无法改变。 晚上在阳台吹了一晚上风。 以为自己打铁打的，结果线上 Ag 了（那 $7$ 分挺可惜的，不然线上 Au 了）。 一看线下 Cu 130，别的不评价了，没资格评价。 闭幕式之后的表演环节没直播，但是知道了好玩的事。 上半年这就是最后一场比赛的，本来说能买个 D 的，结果感觉我穿越到平行世界了。 结束了，感觉最近精神状态一直不太好，空落落的。"},{"title":"ABC299G 题解","date":"2023-04-24T16:00:00.000Z","url":"/posts/AT_abc299_g/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"“まだ動くまだ進む 物語の上を泳げ” —— 《スイマー》 分析维护一个栈，每次加入一个值。 如果栈顶在之后也会出现并且比加入的值大就弹出。 这样使得每个值尽可能放在前面。 粗略的证明一下。假设有两个序列 $A,B$，$A$ 的字典序小于 $B$，且 $A$ 是字典序最小的。 $A$ 的第一个与 $B$ 不同的位置为 $x$，$A_x$ 在 $B$ 中出现的位置 $y$ 一定在 $x$ 之后。 $B_y$ 能移动到 $x$，在处理 $B$ 的时候 $B_y$ 会被移动到 $x$，所以不会找到 $B$ 序列。 那么找到的序列是字典序最小的。 不过一个排列的置换字典序最小不一定代表这个排列的字典序最小。 代码"},{"title":"P4200 题解","date":"2023-04-16T16:00:00.000Z","url":"/posts/P4200/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["平衡树","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“遥か月を目指した 今日の空は 彼方西に流れた もう届かないや 届かないや”——《回る空うさぎ》 分析首先对于每个坐标开一颗平衡树，要维护的东西需要全局取 max，但是自己不能取。 士气值和团结值在一个点没加进去之前是好算的，直接是坐标内部的点威武值的最大值和点的个数。 然后就是要更新坐标上的所有点，先给平衡树的根节点打上标记，打完之后再把点加进去。 现在这个点的标记就不会打在自己身上了。 代码 后话至少 2023.04.17 我还是最优解。"},{"title":"ABC295G 题解","date":"2023-03-26T16:00:00.000Z","url":"/posts/AT_abc295_g/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"],["并查集","/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"],["强连通","/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A/"]],"categories":[["undefined",""]],"content":"“「あるべき人間の姿へ」 「正しい人間の姿へ」 そう思えばなんだか 人間全てが汚く思えてくるな”—— 《不可解》 题意简述给定一张点数为 $N$ 的有向图，初始 $p_i(1\\leq p_i \\leq i,1 \\leq i &lt; N)$ 连向 $i+1$。 $Q$ 次操作，有两种： 1 u v：$u$ 向 $v$ 连一条有向边，保证最开始时 $v$ 能到达 $u$，$u \\ne v$。 2 x：询问 $x$ 能到达的点中编号最小的点。 分析最开始时，$u$ 能到达的所有点都比 $u$ 大。而操作 $1$ 形成了一个强联通分量，走强联通分量内部的点才可能达到更小的点。 一个点 $x$ 能达到的最小的点在 $x$ 所在的强连通分量里，用并查集维护即可。 代码 闲话警惕 abc 打普及 G 牌。"},{"title":"圆方树","date":"2023-03-21T16:00:00.000Z","url":"/posts/%E5%9C%86%E6%96%B9%E6%A0%91/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["圆方树","/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"],["仙人掌","/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"],["图论","/tags/%E5%9B%BE%E8%AE%BA/"]],"categories":[["undefined",""]],"content":"模拟赛考到了，正好写一下。 简介圆方树是一种将图变成树的方法，解决一些路径连通性相关的东西或者是仙人掌。 描述前置知识：点双连通分量。以下不考虑孤立点。 在圆方树中，原来的点为圆点，点双为方点。每个点双内部是一个菊花图 ^1，多个菊花图通过原图中的割点连接在一起。 圆方树有 $n+c$ 个点，$c$ 为原图中点双连通分量的个数。如果原图有 $k$ 个联通分量，那么圆方树会是有 $k$ 颗树的森林。 性质圆方树有优美的性质。 无论如何换根，圆方树形态不变 圆方树的子树 &#x3D; 原仙人掌的子仙人掌 相同种类的点不会相连 算法在找点双的时候，新找到一个点双就新建一个方点，与点双内部所有点连边即可。 题目无向图相关[APIO2018] 铁人两项建出圆方树，枚举中转点 $c$ 统计答案。 $c$ 为圆点，$c$ 的每一个儿子 $v$ 子树内的点都能和其他子树内的点组成合法的 $(s,f)$，贡献为 $size_v \\times (size_c-size_v-1)$（$size$ 是原本的树的大小）。 $c$ 为方点，计算的是以这个点双中的某个点作为 $c$，$(s,f)$ 中至少有一个点在点双内，且没有被圆点统计到的答案。$(s,f)$ 中有一个点在点双内，共有 $deg_c-1$ 种，但是在割点出被圆点统计到了一次，所以有 $deg_c-2$ 种。 用换根 DP 也统计父亲的答案就行了。 CF487E Tourists经过的点双的并就是所有可能路径的并，也就是问经过的所有点双中边权的最小值。 建圆方树，查询可以用树剖解决，问题在修改。 修改时计算更新所有相连的方点是不行的，菊花图就可以卡掉。 一个圆点的贡献挂到父亲上，父亲一定是方点。但是这样点双会缺一个点，缺的是深度最小的圆点，这个点被计算到了上方的点双里。 查询 $x,y$ 经过的点双除了包含 $lca(x,y)$ 的一定都能覆盖完全，缺的只有 $lca(x,y)$。单独贡献 $lca(x,y)$ 即可，如果 $lca(x,y)$ 是方点则贡献 $fa_{lca(x,y)}$。 对每个方点维护一个 multiset，查询用树剖 + 线段树求最小值。 "},{"title":"ABC279F 并查集题解","date":"2023-03-19T16:00:00.000Z","url":"/posts/AT_abc294_f/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"],["并查集","/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"]],"categories":[["undefined",""]],"content":"“我仍然在无人问津的阴雨霉湿之地” —— 《世末歌者》 题意高橋君有 $N$ 瓶糖水，青木君有 $M$ 瓶糖水。 高橋君的第 $i$ 瓶糖水有 $A_i$ 份糖 $B_i$ 份水。 青木君的第 $i$ 瓶糖水有 $C_i$ 份糖 $D_i$ 份水。 将两人的糖水各选一瓶混合有 $NM$ 种可能，求其中浓度第 $k$ 大的糖水浓度是多少。 有 $x$ 份糖和 $y$ 份水的糖水浓度是 $\\dfrac{100x}{x+y}%$。 分析二分浓度 $c$ 后，我们只需要得到混合后浓度大于等于 $c$ 的个数。 有 $a$ 份糖 $b$ 份水的糖水，再加 $(a+b)c-a$ 份糖就能变成浓度 $c$，也可能是减掉糖。 令 $(a+b)c-a$ 为 $s$，$s$ 的正负可以判断浓度和 $c$ 的关系。 那么两瓶糖水 $x,y$ 混合后，判断 $s_x+s_y$ 的正负即可。 因为 $(A_x+B_x+C_y+D_y)c-A_x-C_y&#x3D;(A_x+B_x)c-A_x+(C_y+D_y)c-C_y&#x3D;s_x+s_y$，所以 $s$ 是可加的。 二分浓度，将青木君糖水的 $s$ 排序，枚举高橋君的糖水，二分计算混合后浓度大于等于 $c$ 的个数。 复杂度 $O(n \\log n \\log v)$。 代码"},{"title":"可持久化线段树 basic!","date":"2023-03-14T16:00:00.000Z","url":"/posts/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["线段树","/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"],["可持久化线段数","/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%95%B0/"],["可持久化","/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"]],"categories":[["undefined",""]],"content":"都是典中典，我之前还不是很会。 简介对于一颗正常的线段树，如果要支持所有版本都既可以访问又可以修改（完全可持久化），对于每个版本保存一颗线段树是不可接受的。 发现每次修改操作修改的点的个数只有 $\\log n$ 个，于是通过记录根节点保存插入后修改的节点和未修改的节点，就可以实现可持久化。 区间问题大概就是两个区间范围限制，一个用值域搞掉，一个用根节点搞掉。 静态区间第 k 大考虑全局第 k 大怎么用线段树做，对值域建线段树，然后在线段树上二分。如果问题为求 $[1,r]$ 的第 k 大，那么找到插入 $r$ 时的版本就行了。 回到原问题，发现我们统计的信息是前缀和，在二分时将 $[1,l-1]$ 和 $[1,r]$ 的相减就行了。 带修区间第 k 大和静态一样，利用前缀和的性质。暴力修改前缀和是不可接受的，考虑用树状数组维护主席树的根节点，每次取出树状数组的 $\\log n$ 个节点计算前缀和即可。 时间复杂度 $O(n \\log^2 n)$，空间 $O(n \\log n)$。 树上主席树板子在树上用主席树做一个前缀和的东西，和区间类似，拿着 $x,y,lca(x,y),fa(lca(x,y))$ 去二分即可。 异或&#x2F;可持久化trie 相关平移后的异或问题其实就是区间操作的典题，不过用了可持久化 trie 的思想。 从高到底枚举 $b$ 的第 $i$ 位，如果区间内存在 $[b+2^{c_i \\ xor 1}-x,b+2^{c_i \\ xor 1}-x+2^k-1]$ 之间的数，那么 $b \\ xor (a+x)$ 的这一位可以为 $1$，因为这个区间里的数加 $x$ 后第 $i$ 位都是 $c_i \\ xor 1$。 可持久化 trie 是个和可持久化线段树差不多的东西。 "},{"title":"ARC158C 题解","date":"2023-03-12T16:00:00.000Z","url":"/posts/AT_arc158_c/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"“かけがえのない日々を ここで 積みかさねて ひとつひとつ いまさらわかった”—— 《想いよひとつになれ》 题意简述设 $f(x)$ 为 $x$ 的数字和。例如 $f(158)&#x3D;1+5+8&#x3D;14$。 给定一个长度为 $N$ 的正整数序列 $A$，求 $\\sum_{i&#x3D;1}^{N}\\sum_{j&#x3D;1}^{N}f(A_i+A_j)$。 分析设 $g(a,b)$ 为 $a+b$ 进位的次数，则 $f(a+b)&#x3D;f(a)+f(b)-9 \\times g(a,b)$，其中 $\\sum_{i&#x3D;1}^{N}\\sum_{j&#x3D;1}^{N}f(A_i)+f(A_j)&#x3D;2 n \\times \\sum_{i&#x3D;1}^{N} f(A_i)$。 考虑如何计算 $\\sum_{i&#x3D;1}^{N}\\sum_{j&#x3D;1}^{N}g(A_i,A_j)$。对于两个数 $x,y$，如果 $x+y$ 在第 $d$ 位上有进位，当且仅当 $x \\bmod 10^d+y \\bmod 10^d \\geq 10^{d+1}$。将所有 $A_i \\bmod 10^d$ 排序，枚举 $d$ 和 $A_j$ 去二分 $A_i \\bmod 10^d$ 中大于 $10^{d+1}-A_j \\bmod 10^d$ 的值的个数即可。 代码"},{"title":"联通性相关","date":"2023-03-12T16:00:00.000Z","url":"/posts/%E8%81%94%E9%80%9A%E6%80%A7%E7%9B%B8%E5%85%B3/","tags":[["强连通","/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["图论","/tags/%E5%9B%BE%E8%AE%BA/"],["点双连通","/tags/%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A/"],["边双连通","/tags/%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A/"]],"categories":[["undefined",""]],"content":"发现这部分学的最烂，稍微整理下。 强连通分量定义强连通的定义：有向图 $G$ 强连通，当且仅当 $G$ 的任意两个节点联通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图。 Tarjan 算法DFS 生成树有向图的 DFS 生成树主要有 $4$ 种边： 树边：是搜索时找到一个未访问的结点形成的边。 返祖边：是搜索时找到自己的祖先形成的边。 横叉边：是搜索时找到已遍历过的结点形成的边，并且这个节点不是自己的祖先和子树中的结点。 前向边：是搜索时找到子树中的结点形成的边。 DFS 生成树与强连通分量之前的关系如果 $u$ 是某个强连通分量在 DFS 生成树里搜到的第一个结点，这个强连通分量其它的结点一定在 $u$ 的子树里。结点 $u$ 被称为这个强连通分量的根。 证明：假设强连通分量其它的结点不都在 $u$ 的子树里，那么不在的那些结点一定与 $u$ 连有返祖边或者前向边，返祖边或者前向边相连的点都是遍历过的，所以该假设不成立。 Tarjan 算法求强连通分量维护对于每个结点 $u$ 维护两个值： $dfn_u$ 表示结点 $u$ 是第几个被搜到的。 $low_u$ 表示在 $u$ 的子树中能够回溯到的最早出现在栈中的结点。具体的，$low_u$ 为以 $u$ 为根的子树的和子树中通过一条不在搜索树上的边能到达的结点的 $dfn$ 的最小值。 按照深度优先搜索依次搜索每个值，对于每个值维护 $dfn$ 和 $low$。每找到一个强连通分量，就将这个强连通分量全部出栈（该强连通分量的所有元素都在栈顶）。在搜索过程中对于 $u$ 与其相连的结点 $v$（$v$ 不是 $u$ 的父亲）： $v$ 未被访问过：继续对 $v$ 进行搜索，用 $low_v$ 更新 $low_u$，因为 $v$ 能够回溯到的点 $u$ 一定也能回溯到。 $v$ 被访问过且在栈中：根据定义，用 $dfn_v$ 更新 $low_u$。 $v$ 被访问过且不在栈中：说明 $v$ 已经被处理，不做更新。 代码实现 割点和桥定义对于一张无向图，如果删去一个点后这张图的联通分量增加了，那么这个点是这张图的割点。 对于一张无向图，如果删去一条边后这张图的联通分量增加了，那么这条边是这张图的桥。 Tarjan 算法求割点dfs 记录时间戳 $low$，同时记录每个结点不经过父亲能到达的结点最小的时间戳 $low$。 判断一个点 $u$ 是割点的依据是存在儿子$v$ 满足 $low_v \\leq dfn_u$。因为如果 $low_v \\geq dfn_u$，说明 $v$ 一定有一条返祖边或者横叉边，删掉 $u$ 之后 $v$ 仍然与 $u$ 的父亲联通，否则删到 $u$ 之后 $v$ 不连通，出现新的联通分量。 这个判定唯一不适用于 $u$ 是根节点。因为根节点的儿子不可能与根节点的父亲联通（根节点没有父亲），所以如果根节点是割点，那么在 dfs 树中存在两个以上的儿子就一定是割点，删掉根结点后根结点的子树一定不连通。 代码实现 Tarjan 算法求割边和求割点差不多，不需要特殊处理根节点。 $low_u$ 为不经过 $u-v$ 这条边能到达的结点的最小时间戳。当 $low_v &gt; dfn_u$ 时，$u-v$ 这条边是割边。因为 $low_v &#x3D; low_u$ 就证明 $v$ 可以通过别的边到达 $u$。 代码实现 双连通分量定义在一张无向图中，对于两个点 $u,v$，如果删去任意一条边都不能使其不连通，那么 $u$ 和 $v$ 是 边双连通 的。 在一张无向图中，对于两个点 $u,v$，如果删去任意一个点都不能使其不连通，那么 $u$ 和 $v$ 是 点双连通 的。 边双连通具有传递性，点双连通没有。 Tarjan 算法求点双连通与边双连通不同，一个点可能属于多个点双连通分量。 除了独立点，所有点双连通都有两个以上的点构成。我们用栈维护点，当遇到割点或根节点时，将子树内目前不属于其它点双的非割点或在子树中的割点归到一个新的点双。注意这个点可能还是与其它点双的公共点，所以不能将其出栈。 代码实现 Tarjan 算法求边双连通删掉割边所剩下的就是边双连通分量。割边用 Tarjan 求即可。 代码实现"},{"title":"根号数据结构","date":"2023-02-20T16:00:00.000Z","url":"/posts/%E6%A0%B9%E5%8F%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":[["莫队","/tags/%E8%8E%AB%E9%98%9F/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["分块","/tags/%E5%88%86%E5%9D%97/"]],"categories":[["undefined",""]],"content":"很久之前写的烂尾笔记 根号数据结构简介顾名思义，复杂度含 $O(\\sqrt n)$ 的数据结构叫根号数据结构，一般都运用了分块和分值的思想。 分块简介分块的基本思想是，通过对原数据的适当划分，并在划分后的每一个块上预处理部分信息，从而较一般的暴力算法取得更优的时间复杂度，或和其他算法搭配平衡出更优的时间复杂度。 使用分块进行维护对数据的特征要求较少 可以维护很多线段树无法维护的东西。 设块长为 $s$ ,复杂度 $O(n&#x2F;s)$， $s$ 取 $\\sqrt n$ 时最优，复杂度为 $O(\\sqrt n)$ 。 缺点是 $O(\\sqrt n)$ 的复杂度比 $O(\\log n)$ 满了不少 但是在部分问题上分块在复杂度或者常数上优于 $O(\\log ^2 n)$ 的树套树解法。 分类 序列分块 对于一个序列按每 $s$ 个元素进行分块，通过修改零散块内元素和修改整块元素去解决问题。 通常修改块内元素为暴力修改之后更新整块信息，修改整块元素则是以区间标记的形式修改。 值域分块 在值域上按每 $s$ 个元素进行分块，通过修改零散块内元素时修改整块元素去解决问题。 因为在值域本就存在一维偏序关系，即数据是有序的，所以可以依据序列分块的思想去解决问题。 通常用来平衡复杂度，例如 $O(1)$ 修改 $O(\\sqrt n)$ 查询的全局最大值。 询问分块 对于每 $s$ 个询问进行分块，即一次处理 $s$ 个元素，同时进行 $n&#x2F;s$ 次全局维护操作。 通常用于需要较大时间维护全局，但是可以以较小时间进行单次查询的问题，也是平衡复杂度的思想。 其他 例如块状链表等等。 莫队简介一种通过暴力移动端点去离线解决区间问题的方法。发明者为国集队长莫涛，所以被称为莫队。 算法发现过程 (大概?)查询一个区间可以暴力的从左端点扫到右端点。当我们有两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 需要查询时且 $[l_1,r_1] \\cap [l_2,r_2] \\ne \\emptyset$ 时，我们可以在扫描完 $[l_1,r_1]$ 之后继续从左到右扫描 $(r_1,r_2]$，同时撤销从左到右撤销 $[l_1,l_2)$。这种方式确实减少了扫描次数，但可以轻松构造数据使复杂度为 $O(n^2)$。 考虑分块的思想，限制端点移动范围。设块长为 $S$ ,对于 $l$ 在同一块内放在一起操作，同时按 $r$ 从小到大排序。这样 $l$ 在一次操作内最多移动 $S$ 次，$r$ 在同一块内最多移动 $n$ 次，所以 $l$ 的移动次数为 $m \\cdot S$，$r$ 的移动次数为 $\\dfrac{n^2}{S}$，这样复杂度为 $O(mS+\\dfrac{n^2}{S})$。 可证在最优的情况下 $S$ 为 $\\dfrac{n}{\\sqrt m}$ 时最优。事实上如果对块长的设定不准确将会对复杂度造成很大影响，例如当 $m$ 与 $\\sqrt n$ 同阶时，若将块长误设成 $\\sqrt n$，复杂度将为$n \\sqrt n$。 一些细节 莫队可以维护的数据需要支持在区间头或者尾加上或者删除,(也有不需要支持删除的莫队，详见回滚莫队)，比线段树之类的数据结构适用性更加更加广泛。 一般的莫队不支持修改 (也有支持修改的莫队，详见带修莫队)。 莫队是一种离线算法，对于强制在线的题目和信息学竞赛之外的方面应该没有啥用途。 板子题 小B的询问 [国家集训队] 小 Z 的袜子 分类 带修莫队 回滚莫队 莫队配合分块&#x2F;bitset 带修莫队简介一般的莫队是无法支持修改的，因为一般无法做到在区间内修改快速更新 (要是可以就不需要莫队了)。及解决方法和 dp 类似，我们可以加一个维度。落实到带修莫队就是加一个时间维度，区间变为$[l,r,time]$。 转移和普通莫队一样转移，但是我们的排序多了一个关键字，以 $O(n^{\\frac{2}{3}})$ 为一块，总复杂度为 $O(n^{\\frac{5}{3}})$。 板子题 [国家集训队] 数颜色 &#x2F; 维护队列 回滚莫队简介莫队配合分块 &#x2F; bitse板子题 曼哈顿交易 P3730 莫队+值域分块题解 "},{"title":"ABC290G 题解","date":"2023-02-19T16:00:00.000Z","url":"/posts/AT_abc290_g/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"“空高く舞う鳥へ かさねたハート”—— 《Jump up HIGH!!》 题意简述有一颗深度为 $D$ 的满 $K$ 叉树，你需要剪掉一些边使其存在大小为 $X$ 的联通分量，求最少剪掉的边的条数。 分析考虑选择 所有 大小大于等于 $X$ 的一颗深度为 $d$ 的满 $K$ 叉树，在剪掉后大小仍超过 $X$ 的情况下剪掉所有与根直接相连的边，也就是剪掉若干个深度为 $d-1$ 的满 $K$ 叉树，再递归处理深度 $d-1$ 的满 $K$ 叉树。注意如果 $d \\ne D$，在树根与树根父节点的连边也要剪掉。 感性理解一下，考虑为什么是对的。在原树上的任意一个子树都可以看成一棵树，树的根节点往上有一条链。先不考虑链，原问题变成了有一颗满 $K$ 叉树，剪掉一些边使得 包含根节点 的联通分量大小为 $x$，求剪掉的边的最少条数。这个问题贪心地剪若干个最大的子树再递归下去显然是对的。上面的做发选择所有大小大于等于 $X$ 的子树就实现了枚举链的长度，所以原贪心也是对的。 复杂度 $O(D^2)$。因为 $1 \\leq \\displaystyle\\sum_{i&#x3D;0}^D{K^i} \\leq 10^{18}$，所以 $D \\leq 60$，复杂度足以通过。 代码 闲话考场写了个只选择最小的大小大于等于 $X$ 的满 $K$ 叉树，WA 了一发，然后在不知道为啥的情况下写了这个过了。"},{"title":"P3730 莫队+值域分块题解","date":"2023-02-18T16:00:00.000Z","url":"/posts/P3730/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["莫队","/tags/%E8%8E%AB%E9%98%9F/"]],"categories":[["undefined",""]],"content":"“生きる熱さを感じたいだけさ”—— 《スリリング・ワンウェイ》 莫队+值域分块题解题意简述查询区间内出现次数第k小的值的出现次数。 $1\\leq N, M\\leq 10^5$ 题目分析这种 $1e5$ 又不带修改的规模容易想到莫队。但是使用平衡树之类 $O(\\log n)$ 插入 $O(\\log n)$ 查询的数据结构搭配莫队，会使复杂度变成 $O(n \\sqrt n \\log n)$，无法通过此题。 考虑平衡复杂度，莫队有 $n \\sqrt n$ 次插入和 $n$ 次查询操作，所以我们最理想的情况下就是找到一个 $O(1)$ 插入 $O(\\sqrt n)$ 查询的数据结构。值域分块 可以解决这个问题，此时总复杂度为 $O(n \\sqrt n)$。 一些细节 题目值域是 $[1,10^9]$，需要离散化。 莫队的最优块长其实是 $\\dfrac{n}{\\sqrt m}$。因为 $n$ 和 $m$ 同价的时候和 $\\sqrt n$ 是一样的，一般也没理这个事。证明详见 普通莫队算法 - Oi Wiki。 代码 后话 这种莫队套分块去平衡复杂度还挺常见的，有时候也搭配 bitset。 第一次写题解，水平有限还请见谅。 "}]