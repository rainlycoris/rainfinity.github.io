<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  <subtitle>だから僕らは がんばって挑戦だよね</subtitle>
  <link href="https://krt.moe/atom.xml" rel="self"/>
  
  <link href="https://krt.moe/"/>
  <updated>2024-07-31T15:00:28.118Z</updated>
  <id>https://krt.moe/</id>
  
  <author>
    <name>All contributors</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P10656 题解</title>
    <link href="https://krt.moe/posts/P10656/"/>
    <id>https://krt.moe/posts/P10656/</id>
    <published>2024-07-15T12:03:00.000Z</published>
    <updated>2024-07-31T15:00:28.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到一定存在包含 $x$ 中 $\sum_{j&#x3D;1}^ix_j\geq\sum x$ 的第一个 $i$ 的最优方案。因为如果不包含，也就是 $x$ 和 $y$ 选择的两段都小于各自的 $\sum$，那么把 $x$ 和 $y$ 中 $\sum$ 大的那一个全选更优。对于 $y$ 同理。</p><p>也就是已经知道常数个位置中的某个会被包含在最优方案，枚举这个位置，假设在 THU 且为 $p$，那么对于 PKU 的 $[l,r]$ 区间，由于相同不能选，就把 THU 切成了很多段，每段都是能选的区间，而 $p$ 一定被选，所以就是 $p$ 所在的那段是答案。</p><p>根据 PKU 的选择区间 $[l,r]$ 可以求出 THU 的 选择区间 $[L,R]$。具体的，$i\in[l,r]$，THU 的 $j$ 和 $i$ 相同</p><ul><li>$j&gt;p$，$R\leftarrow \min(R,j-1)$，</li><li>$j&gt;p$，$L\leftarrow \max(L,j+1)$，</li></ul><p>那么对 PKU 做一个扫描线，需要支持前缀取 $\max$ 和 $\min$ 和求前缀最值。显然 $L,R$ 分别都是单调的，修改的都是一段区间，用线段树解决，递归到能修改才修改，复杂度为 $O(\log n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastio&#123;</span><br><span class="line">    <span class="keyword">struct</span>&#123;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T x=<span class="number">0</span>;<span class="type">char</span> f=<span class="number">0</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">        <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">        <span class="keyword">return</span> f?-x:x;</span><br><span class="line">    &#125;&#125;in;<span class="type">int</span> stk[<span class="number">39</span>],tp;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(T x,<span class="type">char</span> c=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">        <span class="keyword">do</span> stk[tp++]=x%<span class="number">10</span>;<span class="keyword">while</span>(x/=<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">while</span>(tp)<span class="built_in">putchar</span>(stk[--tp]^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(c)<span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> fastio::in;<span class="keyword">using</span> fastio::out;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;</span><br><span class="line"><span class="type">int</span> a[N],x[N],b[N],y[N];</span><br><span class="line"><span class="type">int</span> p[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="type">int</span> l,r,tl,tr;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; vl,vr,v;<span class="type">int</span> L;&#125; tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify_l</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">            tr[u].l = tr[u].tl = v;</span><br><span class="line">            tr[u].v = &#123;tr[u].vr.first-x[v<span class="number">-1</span>],tr[u].vr.second&#125;;</span><br><span class="line">            tr[u].vl = &#123;-x[v<span class="number">-1</span>]-y[tr[u].L<span class="number">-1</span>],tr[u].L&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify_r</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">            tr[u].r = tr[u].tr = v;</span><br><span class="line">            tr[u].v = &#123;tr[u].vl.first+x[v],tr[u].vl.second&#125;;</span><br><span class="line">            tr[u].vr = &#123;x[v]-y[tr[u].L<span class="number">-1</span>],tr[u].L&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].tl)&#123;</span><br><span class="line">                <span class="built_in">modify_l</span>(u&lt;&lt;<span class="number">1</span>,tr[u].tl);</span><br><span class="line">                <span class="built_in">modify_l</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[u].tl);</span><br><span class="line">                tr[u].tl = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].tr)&#123;</span><br><span class="line">                <span class="built_in">modify_r</span>(u&lt;&lt;<span class="number">1</span>,tr[u].tr);</span><br><span class="line">                <span class="built_in">modify_r</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[u].tr);</span><br><span class="line">                tr[u].tr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">            tr[u].l = <span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].l,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l);</span><br><span class="line">            tr[u].r = <span class="built_in">min</span>(tr[u&lt;&lt;<span class="number">1</span>].r,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r);</span><br><span class="line">            tr[u].vl = <span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].vl,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].vl);</span><br><span class="line">            tr[u].vr = <span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].vr,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].vr);</span><br><span class="line">            tr[u].v = <span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].v,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">            tr[u].L = l;</span><br><span class="line">            tr[u].tl = tr[u].tr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                tr[u].l = <span class="number">1</span>;</span><br><span class="line">                tr[u].r = n;</span><br><span class="line">                tr[u].vl = &#123;-y[l<span class="number">-1</span>],l&#125;;</span><br><span class="line">                tr[u].vr = &#123;x[n]-y[l<span class="number">-1</span>],l&#125;;</span><br><span class="line">                tr[u].v = &#123;x[n]-y[l<span class="number">-1</span>],l&#125;;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">            <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify_l</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> R,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(r&gt;R)&#123;</span><br><span class="line">                <span class="built_in">pushdown</span>(u);</span><br><span class="line">                <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">modify_l</span>(u&lt;&lt;<span class="number">1</span>,l,mid,R,v);</span><br><span class="line">                <span class="keyword">if</span>(mid&lt;R)</span><br><span class="line">                    <span class="built_in">modify_l</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,R,v);</span><br><span class="line">                <span class="built_in">pushup</span>(u);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].l&lt;=v)&#123;</span><br><span class="line">                <span class="built_in">modify_l</span>(u,v);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l==r)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">pushdown</span>(u);</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l&lt;v)</span><br><span class="line">                <span class="built_in">modify_l</span>(u&lt;&lt;<span class="number">1</span>,l,mid,R,v);</span><br><span class="line">            <span class="built_in">modify_l</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,R,v);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify_r</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> R,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(r&gt;R)&#123;</span><br><span class="line">                <span class="built_in">pushdown</span>(u);</span><br><span class="line">                <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">modify_r</span>(u&lt;&lt;<span class="number">1</span>,l,mid,R,v);</span><br><span class="line">                <span class="keyword">if</span>(mid&lt;R)</span><br><span class="line">                    <span class="built_in">modify_r</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,R,v);</span><br><span class="line">                <span class="built_in">pushup</span>(u);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].r&gt;=v)&#123;</span><br><span class="line">                <span class="built_in">modify_r</span>(u,v);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l==r)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">pushdown</span>(u);</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r&gt;v)</span><br><span class="line">                <span class="built_in">modify_r</span>(u&lt;&lt;<span class="number">1</span>,l,mid,R,v);</span><br><span class="line">            <span class="built_in">modify_r</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,R,v);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(r&lt;=R)</span><br><span class="line">                <span class="keyword">return</span> tr[u].v;</span><br><span class="line">            <span class="built_in">pushdown</span>(u);</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].L&lt;=R)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].v,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,R));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,mid,R);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[N],r[N];</span><br><span class="line"></span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>,5&gt; <span class="title">solve</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>,3&gt; ans = &#123;&#125;;</span><br><span class="line">    tr.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[b[k]]&gt;xp)</span><br><span class="line">            tr.<span class="built_in">modify_r</span>(<span class="number">1</span>,<span class="number">1</span>,m,k,p[b[k]]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[b[k]])</span><br><span class="line">            tr.<span class="built_in">modify_l</span>(<span class="number">1</span>,<span class="number">1</span>,m,k,p[b[k]]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> [w,l] = tr.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,m,k);</span><br><span class="line">        <span class="keyword">if</span>(w+y[k]&gt;ans[<span class="number">0</span>])</span><br><span class="line">            ans = &#123;w+y[k],l,k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> complete = [&amp;](array&lt;<span class="type">int</span>,<span class="number">3</span>&gt; v) -&gt; array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>,r = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=v[<span class="number">1</span>];k&lt;=v[<span class="number">2</span>];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[b[k]]&gt;xp)</span><br><span class="line">                r = <span class="built_in">min</span>(r,p[b[k]]<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = <span class="built_in">max</span>(l,p[b[k]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;v[<span class="number">0</span>],v[<span class="number">1</span>],v[<span class="number">2</span>],l,r&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complete</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = in,m = in;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        p[a[k] = in] = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        x[k] = x[k<span class="number">-1</span>]+(<span class="type">int</span>)in;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">        b[k] = in;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">        y[k] = y[k<span class="number">-1</span>]+(<span class="type">int</span>)in;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="type">int</span>,5&gt; ans1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(x[k]*<span class="number">2</span>&gt;=x[n])&#123;</span><br><span class="line">            ans1 = <span class="built_in">max</span>(ans1,<span class="built_in">solve</span>(k));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x[k]*<span class="number">2</span>==x[n])&#123;</span><br><span class="line">            ans1 = <span class="built_in">max</span>(&#123;ans1,<span class="built_in">solve</span>(k),<span class="built_in">solve</span>(k+<span class="number">1</span>)&#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        p[a[k]] = k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    array&lt;<span class="type">int</span>,5&gt; ans2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[k]*<span class="number">2</span>&gt;=x[n])&#123;</span><br><span class="line">            ans2 = <span class="built_in">max</span>(ans2,<span class="built_in">solve</span>(k));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x[k]*<span class="number">2</span>==x[n])&#123;</span><br><span class="line">            ans2 = <span class="built_in">max</span>(&#123;ans2,<span class="built_in">solve</span>(k),<span class="built_in">solve</span>(k+<span class="number">1</span>)&#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>(x[n],y[m])&gt;=<span class="built_in">max</span>(ans1[<span class="number">0</span>],ans2[<span class="number">0</span>]))&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[n]&gt;y[m])&#123;</span><br><span class="line">            <span class="built_in">out</span>(x[n],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">            <span class="built_in">out</span>(<span class="number">1</span>,<span class="string">&#x27; &#x27;</span>),<span class="built_in">out</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">out</span>(y[m],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">out</span>(<span class="number">1</span>,<span class="string">&#x27; &#x27;</span>),<span class="built_in">out</span>(m,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans1[<span class="number">0</span>]&gt;ans2[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="built_in">out</span>(ans1[<span class="number">0</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">out</span>(ans1[<span class="number">3</span>],<span class="string">&#x27; &#x27;</span>),<span class="built_in">out</span>(ans1[<span class="number">4</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">out</span>(ans1[<span class="number">1</span>],<span class="string">&#x27; &#x27;</span>),<span class="built_in">out</span>(ans1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">out</span>(ans2[<span class="number">0</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">out</span>(ans2[<span class="number">1</span>],<span class="string">&#x27; &#x27;</span>),<span class="built_in">out</span>(ans2[<span class="number">2</span>],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">out</span>(ans2[<span class="number">3</span>],<span class="string">&#x27; &#x27;</span>),<span class="built_in">out</span>(ans2[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>注意 PKU 和 THU 的第一个超过一半的位置都要算，刚好等于一半的话 $i+1$ 也要计算。记录方案可以只记录一半，另一半可以之后算出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;注意到一定存在包含 $x$ 中 $&#92;sum_{j&amp;#x3D;1}^ix_j&#92;geq&#92;sum x$ 的第一个 $i$ 的最优方案。因为如果不包</summary>
      
    
    
    
    
    <category term="题解" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="笔记" scheme="https://krt.moe/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="扫描线" scheme="https://krt.moe/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>祝 Aqours 九周年</title>
    <link href="https://krt.moe/posts/%E7%A5%9DAqours%E4%B9%9D%E5%91%A8%E5%B9%B4/"/>
    <id>https://krt.moe/posts/%E7%A5%9DAqours%E4%B9%9D%E5%91%A8%E5%B9%B4/</id>
    <published>2024-07-05T05:23:00.000Z</published>
    <updated>2024-07-31T15:02:17.757Z</updated>
    
    <content type="html"><![CDATA[<p>很高兴能认识你们，九周年了，好厉害呢。</p><p>虽然我并没有认识你们九年，大概是在二期动画和剧场版之间吧，我看到了<del>善子</del>夜羽，当时应该是觉得好可爱之类的，然后就第一次见到了 Aqours。</p><p>当时我还小，肯定也不懂这份感情，我也记不清了。只记得那之后石头剪刀布我都是出的善子剪刀手（就是出食指和无名指）。</p><p>不过之后 Aqours 的三次元部分我一直都没看过，可能是太二次元了接受三次元有点困难，直到幻日的夜羽之后。嘛看来幻夜也不是一无是处。</p><p>然后彻底喜欢上了 Aqours，喜欢上了全部。到今天都会后悔自己来的太晚了，之前喜欢的程度完全不够。</p><p>「いっぱい叫んだって足りない　君へのキモチは」</p><p>说到这里啊，就再说说之前的我干啥去了吧。</p><p>最开始，我接触这个世界的第一次，是 Kizuna Ai。</p><p>今天也正好是 Kizuna Ai 的生日呢，生日快乐。</p><p>但是最后还是离我而去了。</p><p>不过今天凌晨油管直播了，说了句 coming back，然后把视频全删了，之后就一直在放之前 pv 的字符画版。</p><p>不过我不抱希望，应该又是在消费死人烂炒。</p><p>然后玩一款两个字的游戏花了比较多的时间，有点后悔。</p><p>然后我一直会听 vocaloid，中 v 的话我很喜欢五维界质，特别是海伊。</p><p>但是也离我而去了。</p><p>真的不想再经历这种事了，何况现在 Aqours 完全是我的一切，别的都无所谓了啊。</p><p>「何か始まるってことは 終わりに繋がるだなんて」</p><p>「考えてもみなかった いや 考えたくなかったんだ」</p><p>现在我对我学 OI 的答案是，只要我能拿到牌子，我就能去看 Aqours 的 live 了，我就能有很多时间和她们在一起了。</p><p>如果没有的话，以我的环境，这是完全不可能的。</p><p>在这之后干嘛，我完全没想过，不过人都是短视的，没有人会想退休之后会干什么，没有人会想死掉之后又怎么样，想了也只会陷入虚无。</p><p>所以，这肯定也算是人生的正解之一。</p><p>本来是 Aqours 的九周年，我却扯了这么多废话。我这个人，满脑子都想着自己呢。</p><p>总之，我很开心，未来还请继续下去，我也会全力应援下去。final live 什么的，请绝对不要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很高兴能认识你们，九周年了，好厉害呢。&lt;/p&gt;
&lt;p&gt;虽然我并没有认识你们九年，大概是在二期动画和剧场版之间吧，我看到了&lt;del&gt;善子&lt;/del&gt;夜羽，当时应该是觉得好可爱之类的，然后就第一次见到了 Aqours。&lt;/p&gt;
&lt;p&gt;当时我还小，肯定也不懂这份感情，我也记不清了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>prufer 序列</title>
    <link href="https://krt.moe/posts/prufer%E5%BA%8F%E5%88%97/"/>
    <id>https://krt.moe/posts/prufer%E5%BA%8F%E5%88%97/</id>
    <published>2024-02-01T16:00:00.000Z</published>
    <updated>2024-07-31T14:56:52.910Z</updated>
    
    <content type="html"><![CDATA[<p>发现标题字打错了，然后改不了标题就重新发了一遍。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>prufer 序列可以把一个结点带标号的树用 $n-2$ 个值域为 $[1,n]$ 的整数表示。</p><p>一棵树对应唯一的 prufer 序列，一个 prufer 序列对应唯一的树，二者为双射关系。</p><h2 id="对树建立-prufer-序列"><a href="#对树建立-prufer-序列" class="headerlink" title="对树建立 prufer 序列"></a>对树建立 prufer 序列</h2><p>每次找到编号最小的 __叶子结点__，把这个结点的父亲放入 prufer 序列的末尾，然后删掉这个叶子。重复 $n-2$ 次。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>显然可以用堆实现，也可以线性构造。</p><p>维护一个 $p$ 表示最小的叶子结点，重复以下操作</p><ol><li>删除 $p$。</li><li>如果父亲成为了叶子，且父亲的编号 $&lt;p$，删除父亲。不断重复 2 操作。</li><li>$p$ 自增直到找到新的叶子结点。</li></ol><p>分析正确性，删除一个点新成为叶子的只会是父亲，如果父亲的编号 $&lt;p$，那么父亲是现在最小的叶子；如果父亲的编号 $&gt;p$，那么父亲会在之后被找到。</p><p>$p$ 只会遍历 $1$ 到 $n$，而删除的时候每条边只会遍历一次，所以复杂度为 $O(n)$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">    d[fa[k]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>,j=<span class="number">1</span>;k&lt;=n<span class="number">-2</span>;k++,j++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(d[j])</span><br><span class="line">        j++;</span><br><span class="line">    p[k] = fa[j];</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=n<span class="number">-2</span>&amp;&amp;!(--d[p[k]])&amp;&amp;p[k]&lt;j)&#123;</span><br><span class="line">        p[k+<span class="number">1</span>] = fa[p[k]];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对-prufer-序列建立树"><a href="#对-prufer-序列建立树" class="headerlink" title="对 prufer 序列建立树"></a>对 prufer 序列建立树</h2><p>prufer 序列里的点的出现次数 $+1$ 就是结点在树上的度数。</p><p>每次找到编号最小的 __度数为 $1$ 的结点__，与当前枚举的 prufer 序列的结点连边，然后这两个点度数 $-1$。</p><p>最后剩下两个度数为 $1$ 的点，其中一个是 $n$，将这两个点连边。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><p>同理可以用堆实现，当然也可以线性构造。</p><p>现在 prufer 序列末尾添加结点  $n$，维护一个 $p$ 表示最小的 __度数为 $1$ 的结点__，重复以下操作</p><ol><li>删除 $p$。</li><li>如果父亲度数变为 $1$ ，且父亲的编号 $&lt;p$，删除父亲。不断重复 2 操作。</li><li>$p$ 自增直到找到新的度数为 $1$ 的点。</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    d[p[k]]++;</span><br><span class="line">p[n<span class="number">-1</span>] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>,j=<span class="number">1</span>;k&lt;n;k++,j++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(d[j])</span><br><span class="line">        j++;</span><br><span class="line">    fa[j] = p[k];</span><br><span class="line">    <span class="keyword">while</span>(k&lt;n&amp;&amp;!(--d[p[k]])&amp;&amp;p[k]&lt;j)&#123;</span><br><span class="line">        fa[p[k]] = p[k+<span class="number">1</span>];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cayley-公式"><a href="#Cayley-公式" class="headerlink" title="Cayley 公式"></a>Cayley 公式</h2><p>完全图 $K_n$ 有 $n^{n-2}$ 棵生成树</p><p>证明可以使用 prufer 序列，purfer 序列有 $n^{n-2}$ 种（长度为 $n-2$ 每个位置可以是 $[1,n]$ 中的一个数），purfer 序列和生成树<br>一一对应，所以有 $n^{n-2}$ 棵生成树。</p><p>类似的：</p><ul><li>$n$ 个点的无根树有 $n^{n-2}$ 种</li><li>$n$ 个点的有根树有 $n \times n^{n-2}$ 种</li><li>$n$ 个点的无根树，每个点的度数为 $d_i$，有 $\frac{(n-2)!}{\prod^{n}<em>{i-1}(d_i-1)!}$ 种，也为 $\prod^{n}</em>{i-1}C_{d_i-1}^{sum}$（sum 为还剩下的位置）</li></ul><h2 id="图连通方案数"><a href="#图连通方案数" class="headerlink" title="图连通方案数"></a>图连通方案数</h2><p>一个 $n$ 个点 $m$ 条边的带标号无向图有 $k$ 个连通块。我们希望添加 $k-1$ 条边使得整个图连通。求方案数。</p><p>感性理解一下，如果把每个连通块看成点，总方案数为 $n^{k-2}$。因为每个位置上填 $[1,n]$ 都有意义。</p><p>然后每个连通块还要和上一个连边，联通块内的每一个点都可能拿出来连，所以总方案数是 $n^{k-2}\times \prod^{k}_{i&#x3D;1}s_i$。</p><p>详细证明之后再说吧。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p>建 prufer 和建树：<a href="https://www.luogu.com.cn/problem/P6086">【模板】Prüfer 序列</a></p><p>Cayley 公式相关：<a href="https://www.luogu.com.cn/problem/P2290">[HNOI2004] 树的计数</a></p><p>图连通方案数：<a href="https://www.luogu.com.cn/problem/CF156D">CF156D Clues</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发现标题字打错了，然后改不了标题就重新发了一遍。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;prufer 序列可以把一个结点带标号的树用 $n-2$ 个值域为 $[1,</summary>
      
    
    
    
    
    <category term="题解" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="prufer 序列" scheme="https://krt.moe/tags/prufer-%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>P9989 题解</title>
    <link href="https://krt.moe/posts/P9989/"/>
    <id>https://krt.moe/posts/P9989/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2024-07-31T15:00:05.581Z</updated>
    
    <content type="html"><![CDATA[<p>“笑って走っていく日も 泣きながら帰る日も この街と共に生きてる”——《街》</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>操作过后的数一定至少变为原来的 $\frac{1}{2}$，所以问题变成了如何判断区间内是否会有数被修改。</p><p>可以维护 $\text{lcm}$，如果 $v$ 不是 $\text{lcm}$ 的倍数就说明存在数会被修改。</p><p>但是 $\text{lcm}$ 可能会很大，但是如果 $\text{lcm}&gt;v$ 那么 $v$ 一定不是 $\text{lcm}$ 的倍数。</p><p>于是限制一个 $\text{lcm}$ 的最大值，$\text{lcm} \leq V$ 时维护具体的值，否则只维护是否 $&gt; V$。</p><p>最多会被修改 $n \log V$ 次，每次修改需要 $O(\log n)$ 的时间去找到，因为辗转相除 $\text{lcm}$ 单点修改的总复杂度为 $O(\log V)$ ，总复杂度 $O(n \log n \log V)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>,V = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> tr[N*<span class="number">4</span>];</span><br><span class="line">        <span class="type">unsigned</span> s[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>]&gt;V||tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]&gt;V)</span><br><span class="line">                tr[u] = V+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tr[u] = tr[u&lt;&lt;<span class="number">1</span>]/<span class="built_in">gcd</span>(tr[u&lt;&lt;<span class="number">1</span>],tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])*tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">            s[u] = s[u&lt;&lt;<span class="number">1</span>]+s[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u]&lt;=V&amp;&amp;v%tr[u]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                s[u] = tr[u] = <span class="built_in">gcd</span>(tr[u],v);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">                <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,mid,L,R,v);</span><br><span class="line">            <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">                <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,v);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">unsigned</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class="line">                <span class="keyword">return</span> s[u];</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(L&lt;=mid&amp;&amp;R&gt;mid)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,mid,L,R)+<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">            <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                s[u] = tr[u] = a[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">            <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = in,m = in;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        a[k] = in;</span><br><span class="line">    tr.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op = in,l = in,r = in;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            tr.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,in);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">out</span>(tr.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“笑って走っていく日も 泣きながら帰る日も この街と共に生きてる”——《街》&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;操作过后的数一定至少变为原来的 $&#92;frac{1</summary>
      
    
    
    
    
    <category term="题解" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="笔记" scheme="https://krt.moe/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="线段树" scheme="https://krt.moe/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>P5494 题解 &amp; 平衡树合并</title>
    <link href="https://krt.moe/posts/P5494/"/>
    <id>https://krt.moe/posts/P5494/</id>
    <published>2023-12-21T16:00:00.000Z</published>
    <updated>2024-07-31T15:00:05.581Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇平衡树合并题解，平衡树合并的复杂度 __并不是假的__，本题复杂度 $O(n \log n)$，更通用的可以证明到 $O(\log^2 n)$，比如支持序列 __全局加全局取膜__。</p><p><a href="https://codeforces.com/blog/entry/108601">https://codeforces.com/blog/entry/108601</a></p><p>和上面的分析相同，但受个人水平所限可能有误，还希望多多包涵，注意下文 $n,V$ 不分。</p><p>平衡树比线段树适用性更广，常数也不大（未卡常 fhqtreap 用时 615ms）。</p><h2 id="平衡树合并"><a href="#平衡树合并" class="headerlink" title="平衡树合并"></a>平衡树合并</h2><p>先不考虑分裂，单说合并。</p><p>现在要合并 $x,y$ 两棵树，选根节点堆值大的当根（假设是 $x$），把 $y$ 的子树按照 $x$ 的键值裂开（这里的裂开就是 treap 的 split），裂开的两瓣和 $x$ 的左右儿子递归下去合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)</span><br><span class="line">        <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].pri&lt;tr[y].pri)</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="built_in">split</span>(y,tr[x].v,l,r);</span><br><span class="line">    tr[x].l = <span class="built_in">Merge</span>(tr[x].l,l);</span><br><span class="line">    tr[x].r = <span class="built_in">Merge</span>(tr[x].r,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显是把小的树裂开更优，但是堆值大大概率就是树大的，下文也默认此情况（主要是带有随机的不会分析）。</p><p>其实这里存在一个合不合并相同结点的问题，其实是 <strong>要合并</strong> 的，因为 treap 的复杂度依赖于树和堆的唯一性，如果存在相同结点那么可能会失去性质（比如全部都一样，可以在不违反树和堆的情况下出来一条链），对于一般的 treap 不存在此问题，因为自带了一个插入时间的比较。</p><p>现在分析平衡树合并的复杂度，设第一棵树大小为 $a$，第二棵为 $b$，不难发现单次合并的复杂度 <strong>上界</strong> 为 $O(\min(a,b)\log(\frac{\max(a,b)}{\min(a,b)}))$，大概是把小的树每个节点都拿去切割大的树，由于 finger search 所以切割复杂度为 $\log(\frac{\max(a,b)}{\min(a,b)})$。总复杂度为 $O(n \log n)$。</p><p>为什么说是上界，因为在两颗树值域重合少的时候复杂度和最少不相交的值域段数 $k$ 有关，合并一次的复杂度为 $O(k \log n)$。</p><h2 id="本题的复杂度分析"><a href="#本题的复杂度分析" class="headerlink" title="本题的复杂度分析"></a>本题的复杂度分析</h2><p>由于合并 $k$ 段值域不相交的复杂度为 $O(k \log n)$，而一次 split 只会产生一段。问题是 $[l,x][x+1,y][y+1,r]$ 如果先合并 $[l,x][y+1,r]$ 再合并 $[x+1,y]$ 会产生额外的一次 $O(\log n)$，但是合并次数等于分裂次数，所以总复杂度为 $O(n \log n)$。</p><h2 id="更通用的复杂度分析"><a href="#更通用的复杂度分析" class="headerlink" title="更通用的复杂度分析"></a>更通用的复杂度分析</h2><p>定义势能为 $\varphi(T)&#x3D;\sum\log(v_{i+1}-v_i)$，也就是 $T$ 相邻的两个值的差的 $\log$ 之和。</p><p>合并 $A$ 和 $B$，有 $k$ 段值域：</p><p>$$<br>\begin{aligned}<br>&amp;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <em>{&lt;-d_1-&gt;}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ </em>{&lt;–d_2–&gt;}\ \ \ \ \ \ \ \ \ \ <em>{&lt;–d_3–&gt;}\ \ \ \ \ \ \ \ \ \ </em>{&lt;—d_4—&gt;}\<br>&amp;A &#x3D; {<em>{[–a_1–]}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ </em>{[-a_2-]}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <em>{[–a_3–]}&amp;}\<br>&amp;B &#x3D; {\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ </em>{[—b_1—]}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{[-b_2-]}&amp;}<br>\end{aligned}<br>$$</p><p>形如 $<em>{[—–]}$ 的是一段值域，形如 $</em>{&lt;–d_i–&gt;}$ 的是值域之间的距离且距离为 $d_i$。</p><p>合并后 $\Delta\varphi&#x3D;\varphi(A)+\varphi(B)-\varphi(A\cup B)$，有<br>$$<br>\Delta\varphi&#x3D;\log(d_1+b_1+d_2)+\log(d_2+a_2+d_3)+\dots+\log(d_{k-1}+a_{\frac{k}{2}}+d_k)-(\log d_1+\dots+\log d_k)<br>$$</p><p>前面的把 $\log(+a_i+)$ 的放在一起就是根据定义算的 $\varphi(A)$，后面的则是由于两段值域不交合并会产生新的势能，势能大小为 $\log$ 值域的距离也就是 $\log(d_i)$。</p><p>显然有<br>$$<br>\Delta\varphi\geq\log(d_1+d_2)+\log(d_2+d_3)+\dots+\log(d_{k-1}+d_k)-(\log d_1+\dots+\log d_k)<br>$$</p><p>因为 $\log$ 函数是下凸的，可得 $\log(\frac{a+b}{2})\geq \frac{\log a+\log b}{2}$，把 $\log$ 里的 $\frac{1}{2}$ 拿出来可得<br>$$<br>\log(a+b)\geq 1+\frac{\log a+\log b}{2}<br>$$</p><p>那么把 $\log(d_{i-1}+d_i)$ 全部拆开，可得<br>$$<br>\Delta\varphi\geq k-1-\frac{d_1+d_k}{2}<br>$$</p><p>忽略常数可得<br>$$<br>\Delta\varphi\geq k-O(\log V)<br>$$</p><p>也就是说最多做 $n \log V$ 次 split，总复杂度为 $O(n \log V \log n)$。</p><h2 id="带有分裂的复杂度分析"><a href="#带有分裂的复杂度分析" class="headerlink" title="带有分裂的复杂度分析"></a>带有分裂的复杂度分析</h2><p>一次分裂会减少 $\log V$ 的势能，split 是不增加势能的。</p><p>一次合并如果增加就至多增加 $\log V$ 的势能（原因可以看上面的式子）。</p><p>那么最多就只有 $n\log V$ 的势能，而 $\Delta \varphi$ 最大就是把这些势能都减少完，所以总复杂度为 $O(n \log n \log V)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">myrand</span><span class="params">(<span class="number">713</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fhqtreap</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="type">int</span> l,r,v,s,siz;<span class="type">unsigned</span> pri;&#125; tr[<span class="number">2</span>*N];</span><br><span class="line">        <span class="type">int</span> rt[N];</span><br><span class="line">        <span class="type">int</span> idx;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">create</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> s)</span></span>&#123;tr[++idx] = &#123;<span class="number">0</span>,<span class="number">0</span>,v,s,s,<span class="built_in">myrand</span>()&#125;;<span class="keyword">return</span> idx;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;tr[u].siz = tr[tr[u].l].siz+tr[tr[u].r].siz+tr[u].s;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span>&amp; <span class="keyword">operator</span> [] (<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> rt[x];&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">                x = y = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].v&lt;=c)&#123;</span><br><span class="line">                x = u;</span><br><span class="line">                <span class="built_in">split</span>(tr[u].r,c,tr[x].r,y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                y = u;</span><br><span class="line">                <span class="built_in">split</span>(tr[u].l,c,x,tr[y].l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">split_rk</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">                x = y = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr[tr[u].l].siz+tr[u].s&lt;=c)&#123;</span><br><span class="line">                x = u;</span><br><span class="line">                <span class="built_in">split_rk</span>(tr[u].r,c-tr[tr[u].l].siz-tr[u].s,tr[x].r,y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                y = u;</span><br><span class="line">                <span class="built_in">split_rk</span>(tr[u].l,c,x,tr[y].l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x||!y)</span><br><span class="line">                <span class="keyword">return</span> x|y;</span><br><span class="line">            <span class="keyword">if</span>(tr[x].pri&gt;tr[y].pri)&#123;</span><br><span class="line">                tr[x].r = <span class="built_in">merge</span>(tr[x].r,y);</span><br><span class="line">                <span class="built_in">pushup</span>(x);</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            tr[y].l = <span class="built_in">merge</span>(x,tr[y].l);</span><br><span class="line">            <span class="built_in">pushup</span>(y);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x||!y)</span><br><span class="line">                <span class="keyword">return</span> x|y;</span><br><span class="line">            <span class="keyword">if</span>(tr[x].pri&lt;tr[y].pri)</span><br><span class="line">                <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="type">int</span> l,r;</span><br><span class="line">            <span class="built_in">split</span>(y,tr[x].v,l,r);</span><br><span class="line">            tr[x].l = <span class="built_in">Merge</span>(tr[x].l,l);</span><br><span class="line">            tr[x].r = <span class="built_in">Merge</span>(tr[x].r,r);</span><br><span class="line">            <span class="built_in">pushup</span>(x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> c,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">split</span>(u,c,x,y);</span><br><span class="line">            u = <span class="built_in">merge</span>(<span class="built_in">merge</span>(x,<span class="built_in">create</span>(c,s)),y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">split_rk</span>(u,K<span class="number">-1</span>,x,y);</span><br><span class="line">            <span class="type">int</span> p = y;</span><br><span class="line">            <span class="keyword">while</span>(tr[p].l)</span><br><span class="line">                p = tr[p].l;</span><br><span class="line">            u = <span class="built_in">merge</span>(x,y);</span><br><span class="line">            <span class="keyword">return</span> p?tr[p].v:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">split</span>(u,l<span class="number">-1</span>,x,y);</span><br><span class="line">            <span class="built_in">split</span>(y,r,y,z);</span><br><span class="line">            <span class="type">int</span> ans = tr[y].siz;</span><br><span class="line">            u = <span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">split</span>(x,l<span class="number">-1</span>,a,b);</span><br><span class="line">            <span class="built_in">split</span>(b,r,b,c);</span><br><span class="line">            y = b;</span><br><span class="line">            x = <span class="built_in">merge</span>(a,c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = in,m = in;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        tr.<span class="built_in">insert</span>(tr[<span class="number">1</span>],k,in);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op = in,p = in;</span><br><span class="line">        <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">            <span class="type">int</span> x = in,y = in;</span><br><span class="line">            tr.<span class="built_in">move</span>(tr[p],tr[++idx],x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> t = in;</span><br><span class="line">            tr[p] = tr.<span class="built_in">Merge</span>(tr[p],tr[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = in,q = in;</span><br><span class="line">            tr.<span class="built_in">insert</span>(tr[p],q,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = in,y = in;</span><br><span class="line">            <span class="built_in">out</span>(tr.<span class="built_in">count</span>(tr[p],x,y),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">out</span>(tr.<span class="built_in">kth</span>(tr[p],in),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局加全局取膜"><a href="#全局加全局取膜" class="headerlink" title="全局加全局取膜"></a>全局加全局取膜</h3><p>全局加不影响势能。</p><p>如果取模的过程中把树分成了 $k$ 段，合并后产生了至多 $(k-1) \log v$ 的势能，但是 $v$ 也会变成 $\dfrac{v}{k}$。把 $\log v$ 提到外面来，显然每轮最劣的 $k$ 都是一样的，因为这是一个递归的问题。原问题变成了 $k$ 使得 $k\log_k n$ 最大。解得最小值取 $e$，最大值为 $n$。所以增加的势能最大为 $n \log v$。</p><p>所以总复杂度为 $O(n \log n\log v)$。</p><h3 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h3><p>确实这东西很能拓展，只要不咋影响势能都可以把合并当作基本操作，比如加、除、取膜、开根、翻转。</p><p>其实全局取膜作用与值域区间也是对的，值域区间完全可以把它当成两个独立的序列分别操作后再 merge 起来，分别操作也就是 $(n-m)\log v+m \log v&#x3D; n\log v$，完全不影响。最后只是常数段的 merge 新增的 $\log v$ 的势能。所以只会增加总共 $n \log v$ 的势能。别的同理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇平衡树合并题解，平衡树合并的复杂度 __并不是假的__，本题复杂度 $O(n &#92;log n)$，更通用的可以证明到 $O(&#92;log^2 n)$，比如支持序列 __全局加全局取膜__。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/bl</summary>
      
    
    
    
    
    <category term="题解" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="笔记" scheme="https://krt.moe/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="平衡树" scheme="https://krt.moe/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
    <category term="学习笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="平衡树合并" scheme="https://krt.moe/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Blog 索引</title>
    <link href="https://krt.moe/posts/Blog%E7%B4%A2%E5%BC%95/"/>
    <id>https://krt.moe/posts/Blog%E7%B4%A2%E5%BC%95/</id>
    <published>2023-12-20T16:00:00.000Z</published>
    <updated>2024-07-31T15:02:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>君のこころは輝いてるかい？</p><span id="more"></span><p>$\LARGE \mathscr Part\ \rm A\quad\LARGE\textbf{知识}$</p><p>基本都是我乱写的。</p><p>为了便于挑选文章，下面有几种标记 ：</p><ul><li>$\color{blue}\large\circledcirc$ 意为 <strong>内容完善</strong></li><li>$\color{red}\large\circledcirc$ 意为 <strong>内容简略&#x2F;尚不完整</strong></li><li>$\color{purple}\large\circleddash$ 意为 <strong>施工中&#x2F;内容不严谨</strong></li><li>$\checkmark$ 意为 <strong>推荐</strong></li><li>$\dag$ 意为 <strong>过时&#x2F;可能存在错误</strong></li></ul><ol><li>数据结构<ul><li><a href="//rainlycoris.github.io/#/post/17">可持久化线段树</a> $\color{red}\large\circledcirc$</li><li><a href="//rainlycoris.github.io/#/post/40">整体二分</a> $\color{red}\large\circledcirc$ $\dag$</li><li><a href="//rainlycoris.github.io/#/post/44">dsu on tree</a>$\color{red}\large\circledcirc$</li><li><a href="//rainlycoris.github.io/#/post/50">平衡树合并</a>$\color{blue}\large\circledcirc$ $\checkmark$</li></ul></li><li>数学 <ul><li><a href="//rainlycoris.github.io/#/post/41">异或线性基</a> $\color{blue}\large\circledcirc$</li><li><a href="">fmt&amp;fwt</a></li></ul></li><li>图论<ul><li><a href="//rainlycoris.github.io/#/post/13">联通性相关</a> $\color{blue}\large\circledcirc$</li><li><a href="//rainlycoris.github.io/#/post/34">网络流常见建模</a> $\color{purple}\large\circleddash$</li><li><a href="//rainlycoris.github.io/#/post/19">圆方树</a> $\color{red}\large\circledcirc$</li><li><a href="//rainlycoris.github.io/#/post/54">prufer 序</a> $\color{blue}\large\circledcirc$</li></ul></li><li>动态规划</li><li>杂<ul><li><a href="//rainlycoris.github.io/#/post/42">高维前缀和&#x2F;sosdp</a> $\color{blue}\large\circledcirc$</li><li><a href="//rainlycoris.github.io/#/post/48">切比雪夫距离与曼哈顿距离</a> $\color{blue}\large\circledcirc$ $\checkmark$</li></ul></li></ol><p>$\LARGE \mathscr Part\ \rm B\quad\LARGE\textbf{记录}$</p><p>等我写了 200 道就发出来。</p><p>$\LARGE \mathscr Part\ \rm C\quad\LARGE\textbf{杂}$</p><p>也许是文化课相关内容，或者是我感兴趣的一些研究，再者就是杂谈。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;君のこころは輝いてるかい？&lt;/p&gt;</summary>
    
    
    
    
    <category term="索引" scheme="https://krt.moe/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>切比雪夫距离与曼哈顿距离</title>
    <link href="https://krt.moe/posts/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/"/>
    <id>https://krt.moe/posts/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-07-31T14:51:36.050Z</updated>
    
    <content type="html"><![CDATA[<p>内含高维曼哈顿-切比雪夫转换。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>曼哈顿距离：$|x_1-x_2|+|y_1-y_2|$</p><p>切比雪夫距离：$\max(|x_1-x_2|,|y_1-y_2|)$</p><h3 id="更多距离"><a href="#更多距离" class="headerlink" title="更多距离"></a>更多距离</h3><p>欧几里得距离：$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</p><p>$L_m$ 距离：$(|x_1-x_2|^m+|y_1-y_2|^m)^{\frac{1}{m}}$</p><p>$n$ 维欧几里得距离：$\sqrt{\sum_{i&#x3D;1}^n(d_{i1}-d_{i2})^2}$</p><p>$n$ 维曼哈顿距离：$\sum_{i&#x3D;1}^n|d_{i1}-d_{i2}|$</p><p>$n$ 维切比雪夫：$\max_{i&#x3D;1}^n|d_{i1}-d_{i2}|$</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>曼哈顿转切比雪夫：$(x,y)\rightarrow(x+y,x-y)$</p><p>切比雪夫转曼哈顿：$(x,y)\rightarrow(\frac{x+y}{2},\frac{x-y}{2})$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明可以用几何，因为曼哈顿坐标系是通过切比雪夫坐标系旋转 $45^\circ$ 后，再缩小到原来的一半得到的。</p><p>或者纯代数，$x\leq y$ 时 $|x-y|&#x3D;x-y$，$x&lt;y$ 时 $|x-y|&gt;x-y$，转换成 $(x+y,x-y)$ 之后 $\max(|x_1-x_2|,|y_1-y_2|)$ 一定是原来的 $|x_1-x_2|+|y_1-y_2|$ 都取到绝对值的时候，也就是曼哈顿距离，而 $\max(|x_1-x_2|,|y_1-y_2|)$ 就是切比雪夫距离。</p><p>其实是转换成 $(x,y),(-x,y),(x,-y),(-x,-y)$，因为切比雪夫本身有绝对值所以正负效果是一样的，去掉重复一半的就是上面的式子。</p><p>切比雪夫转曼哈顿其实就是解 $\begin{cases}x+y&#x3D;a\cr x-y&#x3D;b\end{cases}$ 的方程。</p><h2 id="高维切比雪夫和曼哈顿"><a href="#高维切比雪夫和曼哈顿" class="headerlink" title="高维切比雪夫和曼哈顿"></a>高维切比雪夫和曼哈顿</h2><p>通过上面的证明可以得到，$k$ 维曼哈顿可以转换为 $2^{k-1}$ 维的切比雪夫。</p><p>也就是指定每一位取正还是取负，在去掉重复的 $\frac{1}{2}$。</p><p>但是高维切比雪夫却不一定都能转换为曼哈顿，因为本质这个转换是解方程，拿四维切比雪夫 $(a,b,c,d)$ 举例</p><p>$$<br>\begin{cases}<br>x+y+z&#x3D;a\cr<br>-x+y+z&#x3D;b\cr<br>x-y+z&#x3D;c\cr<br>x+y-z&#x3D;d<br>\end{cases}<br>$$</p><p>这个方程需要满足 $a&#x3D;b+c+d$ 才能有解，有解情况下</p><p>$$<br>\begin{cases}<br>x&#x3D;\frac{a-b}{2}\cr<br>y&#x3D;\frac{a-c}{2}\cr<br>z&#x3D;\frac{a-d}{2}<br>\end{cases}<br>$$</p><p>而切比雪夫不是 $2^k$ 维的情况下我们可以升维成 $2^k$ 维，这个时候补 $0$ 也有可能使得方程一定有解。</p><p>比如求<br>$$<br>\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^{i-1}\max(a_i-a_j,b_i-b_j,c_i-c_j)-\min(a_i-a_j,b_i-b_j,c_i-c_j)<br>$$</p><p><del>可以直接 min-max 容斥，但是跑的慢</del></p><p>推式子</p><p>$$<br>\begin{aligned}<br>&amp;\max(a_i-a_j,b_i-b_j,c_i-c_j)-\min(a_i-a_j,b_i-b_j,c_i-c_j)\cr<br>&#x3D;&amp;\max(|b_i-b_j-(a_i-a_j)|,|c_i-c_j-(b_i-b_j)|,|a_i-a_j-(c_i-c_j)|)\cr<br>&#x3D;&amp;max(|(b_i-a_j)+(b_j-a_j)|,|(c_i-b_i)+(c_j-b_j)|,|(a_i-c_i)+(a_j-c_j|))<br>\end{aligned}<br>$$</p><p>这明显是一个三维切比雪夫，给他升成四维，令 $a&#x3D;0$，刚好满足 $a&#x3D;b+c+d$，所以原式为</p><p>$$<br>\frac{1}{2}\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^{i-1}|b_i-a_i|+|c_i-b_i|+|a_i-c_i|<br>$$</p><p>这个直接排序就能求了。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>其实不把重复的去掉，保留 $2^k$ 维，这样就不用取 $\text{abs}$ 了，能有比切比雪夫更好的性质。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内含高维曼哈顿-切比雪夫转换。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;曼哈顿距离：$|x_1-x_2|+|y_1-y_2|$&lt;/p&gt;
&lt;p&gt;切比雪夫距离：$&#92;max</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="曼哈顿&amp;切比雪夫" scheme="https://krt.moe/tags/%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB/"/>
    
  </entry>
  
  <entry>
    <title>P2120 题解</title>
    <link href="https://krt.moe/posts/P2120/"/>
    <id>https://krt.moe/posts/P2120/</id>
    <published>2023-11-04T16:00:00.000Z</published>
    <updated>2024-07-31T14:59:21.628Z</updated>
    
    <content type="html"><![CDATA[<p>“生きてく意味があると感じるよ…確かに！”——《Nameless Love Song》</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先写个 $n^2$ dp 转移</p><p>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;\min_{j&#x3D;1}^{i-1}(f_j+\sum_{k&#x3D;j+1}^i(x_i-x_k)p_k)+c_i\<br>  &amp;&#x3D;\min_{j&#x3D;1}^{i-1}(f_j+x_i\sum_{k&#x3D;j+1}^ip_k-\sum_{k&#x3D;j+1}^ix_kp_k)+c_i\<br>  &amp;&#x3D;\min_{j&#x3D;1}^{i-1}(-x_i\sum_{k&#x3D;1}^jp_k+f_j+\sum_{k&#x3D;1}^jx_kp_k)+x_i\sum_{k&#x3D;1}^ip_k-\sum_{k&#x3D;1}^ix_kp_k+c_i<br>\end{aligned}<br>$$</p><p>然后 $\min$ 里面的像一次函数，直接上李超树。</p><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p>要特判末尾连续的 $p_i&#x3D;0$，以及第 $8$ 个点卡李超树，别的 hack 倒是不用管。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>,INF = (<span class="number">1ull</span>&lt;&lt;<span class="number">63</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> x[N],p[N],c[N],f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lctree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="type">int</span> l,r;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; f;&#125; tr[N];</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; f,<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> f.first*x+f.second;&#125;;</span><br><span class="line">        <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> root;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; f)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!u)</span><br><span class="line">                tr[u=++idx].f =  f;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">val</span>(f,mid)&lt;<span class="built_in">val</span>(tr[u].f,mid))</span><br><span class="line">                    <span class="built_in">swap</span>(f,tr[u].f);</span><br><span class="line">                <span class="keyword">if</span>(f.first&gt;tr[u].f.first)</span><br><span class="line">                    <span class="built_in">insert</span>(tr[u].l,l,mid,f);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">insert</span>(tr[u].r,mid+<span class="number">1</span>,r,f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!u)</span><br><span class="line">                <span class="keyword">return</span> INF;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">val</span>(tr[u].f,p),p&lt;=mid?<span class="built_in">query</span>(tr[u].l,l,mid,p):<span class="built_in">query</span>(tr[u].r,mid+<span class="number">1</span>,r,p));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = in;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        x[k] = in,p[k] = in,c[k] = in;</span><br><span class="line">        V = <span class="built_in">max</span>(V,x[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    tr.<span class="built_in">insert</span>(tr.root,<span class="number">0</span>,V,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> sp = <span class="number">0</span>,sxp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        sp += p[k];</span><br><span class="line">        sxp += x[k]*p[k];</span><br><span class="line">        f[k] = tr.<span class="built_in">query</span>(tr.root,<span class="number">0</span>,V,x[k])+x[k]*sp-sxp+c[k];</span><br><span class="line">        tr.<span class="built_in">insert</span>(tr.root,<span class="number">0</span>,V,&#123;-sp,f[k]+sxp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = f[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=n;k&amp;&amp;!p[k];k--)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,f[k<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">out</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“生きてく意味があると感じるよ…確かに！”——《Nameless Love Song》&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;首先写个 $n^2$ dp 转移&lt;/p</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
    <category term="斜率优化" scheme="https://krt.moe/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    <category term="李超树" scheme="https://krt.moe/tags/%E6%9D%8E%E8%B6%85%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 dsu on tree</title>
    <link href="https://krt.moe/posts/dsu_on_tree/"/>
    <id>https://krt.moe/posts/dsu_on_tree/</id>
    <published>2023-10-30T16:00:00.000Z</published>
    <updated>2024-07-31T14:55:07.055Z</updated>
    
    <content type="html"><![CDATA[<p>契约签订完毕，接下来要认真起来了。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于子树查询类问题，大多可以 dfs 序然后上数据结构，不行就树上莫队。</p><p>一个方法是 dsu on tree，是一个好写的复杂度 $O(n \log n)$ 离线算法。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>考虑启发式，对于每个节点找出重子树，然后</p><ul><li>递归询问所有轻子树（询问后删除贡献）</li><li>递归询问重子树（保留贡献）</li><li>加入所有轻子树内节点的贡献</li></ul><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>对于复杂度，总操作次数为 $n+\sum$ 轻子树大小。类似于树链剖分，每个点被多操作一次就代表成为了一次轻子树，而轻子树的父亲的子树大小至少为轻子树的 $2$ 倍，所以每个点至多被操作 $\log$ 次。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>加入重儿子之前的全局所有贡献都是被删掉了的。</p><p>这意味着 dsu on tree 和 $O(n^2)$ 去统计在贡献处理上没有任何区别，也意味着回滚莫队能做的都能做。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="CF600E-Lomsat-gelral"><a href="#CF600E-Lomsat-gelral" class="headerlink" title="CF600E Lomsat gelral"></a><a href="https://codeforces.com/problemset/problem/600/E">CF600E Lomsat gelral</a></h3><p>直接 dsu on tree，求众数和可以正常做，撤销的时候不仅要把计数的数组撤销，还要把最多出现次数和众数和撤销，后者也好办，操作前记录一个撤销的时候直接赋值就好了。</p><h3 id="CF741D-Arpa’s-letter-marked-tr…"><a href="#CF741D-Arpa’s-letter-marked-tr…" class="headerlink" title="CF741D Arpa’s letter-marked tr…"></a><a href="https://codeforces.com/problemset/problem/600/E">CF741D Arpa’s letter-marked tr…</a></h3><p>排序后能是回文串要么每个字符都是偶数，或者只有一个为奇数。</p><p>字符只有 $22$ 个，可以记录某些字符出现奇数的最长长度，然后类似于点分治去统计。</p><p>把这个过程按照 dsu on tree 做就好了。</p><h3 id="CF1767F-Two-Subtrees"><a href="#CF1767F-Two-Subtrees" class="headerlink" title="CF1767F Two Subtrees"></a><a href="https://codeforces.com/problemset/problem/1767/F">CF1767F Two Subtrees</a></h3><p>如果只询问一个子树，那么就是 dsu on tree 板子。</p><p>考虑把 __dsu on tree 序列化__，先加入轻子树，再加入重子树，再加入根。</p><p>当扫描这个序列的所有子树时，轻子树的移动后会直接被删掉，重子树移动后再查询根，重子树会被保留同时加入所有轻子树，扫描的复杂度为 $O(n \log n)$。</p><p>直接在这个序列上莫队，区间的左右端点为询问的两颗子树。</p><p>子树询问的区间移动就如果目标区间当前区间无交就当前区间删除然后暴力加入目标区间，否则就就正常移动左右端点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;契约签订完毕，接下来要认真起来了。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;对于子树查询类问题，大多可以 dfs 序然后上数据结构，不行就树上莫队。&lt;/p&gt;
&lt;p&gt;一</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="dsu on tree" scheme="https://krt.moe/tags/dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>真·浅谈线性基</title>
    <link href="https://krt.moe/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>https://krt.moe/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/</id>
    <published>2023-09-18T16:00:00.000Z</published>
    <updated>2024-07-31T14:51:33.852Z</updated>
    
    <content type="html"><![CDATA[<p>或许是该努努力了呢，快要来不及了。</p><h2 id="异或线性基"><a href="#异或线性基" class="headerlink" title="异或线性基"></a>异或线性基</h2><p>简单来说，线性基是一个数的集合，每个序列都拥有一个线性基，线性基中的若干个数异或起来原序列中的任意一个数。</p><p>重要性质：</p><ol><li>原序列中的任意一个数都能通过线性基中的若干个数异或得到。</li><li>线性基内任意数异或和不为 $0$。</li><li>一个序列的所有线性基大小相同。</li></ol><p>别的性质：</p><ol start="4"><li>由 $n$ 个数组成的大小为 $s$ 的线性基，能构成 $2^s$ 种不同的数，每个数出现 $2^{n-s}$ 次。</li></ol><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">62</span>;~k;k--)</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;k)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!d[k])&#123;</span><br><span class="line">                d[k] = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x ^= d[k];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求异或最大值"><a href="#求异或最大值" class="headerlink" title="求异或最大值"></a>求异或最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">62</span>;~k;k--)</span><br><span class="line">        <span class="keyword">if</span>((x^d[k])&gt;x)</span><br><span class="line">            x ^= d[k];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求异或最小值"><a href="#求异或最小值" class="headerlink" title="求异或最小值"></a>求异或最小值</h3><p>如果是序列内部最小的异或值，那么如果有元素不能被插入线性基，最小值为 $0$，否则为线性基中最小的元素。</p><p>如果是丢一个数进去的话，类似于求异或最大值做就行了。</p><h3 id="查询存在性"><a href="#查询存在性" class="headerlink" title="查询存在性"></a>查询存在性</h3><p>能插入进去就是不存在，否则就是存在。</p><h3 id="求-k-小值"><a href="#求-k-小值" class="headerlink" title="求 $k$ 小值"></a>求 $k$ 小值</h3><p>先预处理，对于线性基 $d$，如果 $d_i(0 \leq i &lt; n)$ 的二进制位 $j(0 \leq j &lt; i)$ 为 $i$，$d_i$ 异或上 $d_j$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">62</span>;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            <span class="keyword">if</span>((d[k]&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                d[k] ^= d[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;n)</span><br><span class="line">        K--;</span><br><span class="line">    <span class="comment">//n 表示序列长度，s 表示线性基元素个数</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">62</span>;k++)</span><br><span class="line">        <span class="keyword">if</span>((K&gt;&gt;k)&amp;<span class="number">1</span>)</span><br><span class="line">            ans ^= d[k];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性基求并"><a href="#线性基求并" class="headerlink" title="线性基求并"></a>线性基求并</h3><p>把一个线性基的全部元素插入另一个就行。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P3857-TJOI2008-彩灯"><a href="#P3857-TJOI2008-彩灯" class="headerlink" title="P3857 [TJOI2008] 彩灯"></a>P3857 [TJOI2008] 彩灯</h3><p>一个序列若干数异或得到的集合和这个序列的线性基异或得到的集合是一样的。</p><p>由于线性基性质 2，一个大小为 $s$ 的线性基能异或得到 $2^s$ 个数。</p><p>那么算出这个序列的线性基，答案就为 $2^s$。</p><h3 id="P4570-BJWC2011-元素"><a href="#P4570-BJWC2011-元素" class="headerlink" title="P4570 [BJWC2011] 元素"></a>P4570 [BJWC2011] 元素</h3><p>因为线性基性质 2，线性基内任意数异或和不为 $0$，考虑线性基。</p><p>因为线性基性质 3，无论顺序能放进去的总个数是不变的，贪心的先放贡献大的就行。</p><h3 id="P5556-圣剑护符"><a href="#P5556-圣剑护符" class="headerlink" title="P5556 圣剑护符"></a>P5556 圣剑护符</h3><p>距离 $&gt;30$ 的路径是一定存在一个子集异或值为 $0$ 的，因为这样线性基一定会被插满。</p><p>那么对于 $\leq 30$ 的暴力用线性基判断，用树剖和线段树维护 lca 和修改。</p><h3 id="P4151-WC2011-最大XOR和路径"><a href="#P4151-WC2011-最大XOR和路径" class="headerlink" title="P4151 [WC2011] 最大XOR和路径"></a>P4151 [WC2011] 最大XOR和路径</h3><p>走的路径一定是一条链然后走到了一些别的地方又回来。</p><p>一个路径走两遍就没了贡献，那么有贡献的一定是走到了环，并且贡献为环本身，因为走去环回来这条路径被走了两遍。</p><p>这样的话所有的环都能自由选择，把所有的小环的异或值加入线性基（大环相当于小环的异或值），就相当于自由选择所有的环。</p><p>考虑选择走的 $1\rightarrow n$ 链，链可以随便选，因为如果有多条链，一定都构成了环，那么选择构成的那个环就相当于选择了另一条链。</p><p>把选择的链的异或值去线性基里跑最大异或值就行了。<a href="https://codeforces.com/problemset/problem/845/G">CF845G</a> 就是跑最小值。</p><h3 id="P5607-Ynoi2013-无力回天-NOI2017"><a href="#P5607-Ynoi2013-无力回天-NOI2017" class="headerlink" title="P5607 [Ynoi2013] 无力回天 NOI2017"></a>P5607 [Ynoi2013] 无力回天 NOI2017</h3><p>首先这是个数据结构套线性基础，考虑线段树，但是修改是区间修改线性基不太好做。</p><p>差分，$b_i&#x3D;a_i\ \text{xor}\  a_i$，把区间修改变为单点修改。</p><p>$a_i$ 可以用 $b_1\ \text{xor}\  b_2 \dots \ \text{xor}\  b_i$ 表示出来，那么 $a_l\dots a_r$ 的所以子集异或都能用 $a_l\ b_{l+1} \ldots b_r$ 表示出来。</p><p>用线段树维护 $b$ 的线性基，同时用树状数组维护 $b$ 的前缀异或和来求 $a_l$。</p><p>询问就求出 $b_{l+1}\dots b_r$ 插入 $a_l$ 然后求异或最大值，特判 $l&#x3D;r$。</p><p>线性基合并的复杂度为 $O(\log^2V)$，所以总复杂度为 $O(n \log n \log^2 V)$。</p><h3 id="P3292-SCOI2016-幸运数字"><a href="#P3292-SCOI2016-幸运数字" class="headerlink" title="P3292 [SCOI2016] 幸运数字"></a>P3292 [SCOI2016] 幸运数字</h3><p>因为是算异或最大值，求的是树上路径线性基，倍增直接做是 $\log m \log^2 V$ 的。</p><p>发现 __线性基重复部分没有贡献__，类似于 $\max,\gcd$ 这些，然后直接用 st 表那种做法做。</p><p>具体的，先倍增预处理线性基。对于询问找到 lca 之后拆成 $x \rightarrow lca$ 和 $y \rightarrow lca$ 两条链。对于一条链 $x\rightarrow y$，倍增找到 $u$ 使得 $dep_u-dep_y+1&#x3D;2^{\lfloor \log({dep_x-dep_y+1}) \rfloor-1}$，复杂度瓶颈在于合并线性基的 $O(\log^V)$，找 $u$ 的 $O(\log n)$ 无所谓。</p><p>复杂度为 $O(n \log^2 V+n \log^3 n)$，$n$ 比 $V$ 小足以通过。</p><h3 id="P4869-albus就是要第一个出场"><a href="#P4869-albus就是要第一个出场" class="headerlink" title="P4869 albus就是要第一个出场"></a>P4869 albus就是要第一个出场</h3><p>由 $n$ 个数组成的大小为 $s$ 的线性基，能构成 $2^s$ 种不同的数，每个数出现 $2^{n-s}$ 次。</p><p>查询排名就是从低位到高位看，如果第 $i$ 位存在线性基且查询的数 $q$ 二进制的第 $i$ 为 $1$，记 $c$ 为 $[0,i)$ 的线性基个数，排名加上 $2^c$。</p><p>因为是第 $i$ 位存在线性基，相当于强制选了第 $i$ 位，这样就不会算重。</p><p>不会证明，之后再补吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;或许是该努努力了呢，快要来不及了。&lt;/p&gt;
&lt;h2 id=&quot;异或线性基&quot;&gt;&lt;a href=&quot;#异或线性基&quot; class=&quot;headerlink&quot; title=&quot;异或线性基&quot;&gt;&lt;/a&gt;异或线性基&lt;/h2&gt;&lt;p&gt;简单来说，线性基是一个数的集合，每个序列都拥有一个线性基，线性基中</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="线性基" scheme="https://krt.moe/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>真·浅谈高维前缀和/sosdp</title>
    <link href="https://krt.moe/posts/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>https://krt.moe/posts/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</id>
    <published>2023-09-18T16:00:00.000Z</published>
    <updated>2024-07-31T14:51:32.312Z</updated>
    
    <content type="html"><![CDATA[<p>夜空是否全然知晓？</p><h2 id="高维前缀和-sosdp"><a href="#高维前缀和-sosdp" class="headerlink" title="高维前缀和&#x2F;sosdp"></a>高维前缀和&#x2F;sosdp</h2><p>计算高维前缀和可以不用容斥，而是对每一维分别做前缀和，复杂度为 $O(kn)$，其中 $k$ 是维度。</p><p>对于子集求和问题，相当于二进制下的 $1$ 可以选 $0$ 或 $1$，$0$ 只能选 $0$，类似于一个高维的前缀和问题。</p><p>那么就可以在 $O(n 2^n)$ 的复杂度之内求出类似于子集和的问题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="ARC100E-Or-Plus-Max"><a href="#ARC100E-Or-Plus-Max" class="headerlink" title="ARC100E Or Plus Max"></a>ARC100E Or Plus Max</h3><p>$i \in k,j \in k$ 是 $i | j &#x3D; k$ 的必要条件，是 $i|j&lt;&#x3D;k$ 的充分条件。</p><p>先算出 $&#x3D;k$ 的答案，在求个前缀最小值就算出了 $\leq k$ 的答案，然后也满足了充要。</p><p>然后就是求子集最大值和次大值，高维前缀和解决。</p><h3 id="CF1208F-Bits-And-Pieces"><a href="#CF1208F-Bits-And-Pieces" class="headerlink" title="CF1208F Bits And Pieces"></a>CF1208F Bits And Pieces</h3><p>考虑枚举一个 $i$，然后 $d_i|(d_j &amp; d_k)&#x3D;d_i+(d_i &amp; d_j &amp; d_k)$。</p><p>要使得 $d_i &amp; d_j &amp; d_k$ 更大，从高位到低位贪心的看能不能是 $1$。</p><p>假设当前选择的为 $s$，首先 $d_i \in s$，然后存在 $j,k$ 使得 $i &lt; j &lt; k$ 并且 $d_j \in s,d_k \in s$。</p><p>相当于求一个超集的最大值和次大值，这种类似子集和的问题可以用高维前缀和解决。</p><h3 id="P6442-COCI2011-2012-6-KOSARE"><a href="#P6442-COCI2011-2012-6-KOSARE" class="headerlink" title="P6442 [COCI2011-2012#6] KOŠARE"></a>P6442 [COCI2011-2012#6] KOŠARE</h3><p>设选择的集合为 $s$，$f_s$ 为 $\in s$ 的个数，那么集合 $\in s$ 的个数为 $2^{f_s}-1$。</p><p>$f_s$ 可以用高维前缀和算，然后按照 $1$ 的个数容斥就行了。</p><p>也可以再跑一遍差分。</p><h3 id="CF449D-Jzzhu-and-Numbers"><a href="#CF449D-Jzzhu-and-Numbers" class="headerlink" title="CF449D Jzzhu and Numbers"></a>CF449D Jzzhu and Numbers</h3><p>和上一道类似，不过不是跑子集是跑超集。</p><p>然后跑容斥或者差分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;夜空是否全然知晓？&lt;/p&gt;
&lt;h2 id=&quot;高维前缀和-sosdp&quot;&gt;&lt;a href=&quot;#高维前缀和-sosdp&quot; class=&quot;headerlink&quot; title=&quot;高维前缀和&amp;#x2F;sosdp&quot;&gt;&lt;/a&gt;高维前缀和&amp;#x2F;sosdp&lt;/h2&gt;&lt;p&gt;计算高维前缀和</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高维前缀和" scheme="https://krt.moe/tags/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>整体二分浅谈</title>
    <link href="https://krt.moe/posts/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    <id>https://krt.moe/posts/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</id>
    <published>2023-08-31T16:00:00.000Z</published>
    <updated>2024-07-31T14:51:30.447Z</updated>
    
    <content type="html"><![CDATA[<p>浅浅的总结一下简单情况。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>可以使用整体二分解决的题目需要满足以下性质：</p><ul><li>询问的答案具有可二分性</li><li>修改对判定答案的贡献互相独立，修改之间互不影响效果</li><li>修改如果对判定答案有贡献，则贡献为一确定的与判定标准无关的值</li><li>贡献满足交换律，结合律，具有可加性</li><li>题目允许使用离线算法</li></ul><blockquote><p>许昊然《浅谈数据结构题几个非经典解法》</p></blockquote><p>一般来说适用于二分时每次 check 都要预处理，同时预处理代价较大的情况。</p><p>把所有询问一起二分，对于一个 check 就只需要预处理一次。</p><h2 id="特殊情况的处理"><a href="#特殊情况的处理" class="headerlink" title="特殊情况的处理"></a>特殊情况的处理</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>比如区间第 $k$ 小，就和平衡树上类似的，如果不在 $[l,mid]$ 里的，$k$ 要减去 $[l,mid]$ 小于它的个数。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>把修改和询问都视为操作（修改要满足上面的性质）。</p><p>比如带修改区间第 k 大，修改为把 $x$ 位置上的数改成 $y$，当 $mid\geq y$ 时用树状数组在 $x$ 这里 $-1$ 表示删除。</p><h3 id="二维化"><a href="#二维化" class="headerlink" title="二维化"></a>二维化</h3><p>把初始的的都视作修改就能轻松处理。</p><p>类似 <a href="https://www.luogu.com.cn/problem/P1527">P1527 [国家集训队] 矩阵乘法</a>。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>相比每次都撤销 $[l,mid]$ 内的所有预处理，维护一个 $p$ 表示 $[1,p]$ 已经被预处理，然后类似莫队的区间移动去把 $p$ 移动到 $mid$，这样加入和撤销的次数会少一半。</p><p>然后有些预处理操作不用撤销可以换成区间操作，就能少一个 $\log$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浅浅的总结一下简单情况。&lt;/p&gt;
&lt;h2 id=&quot;适用范围&quot;&gt;&lt;a href=&quot;#适用范围&quot; class=&quot;headerlink&quot; title=&quot;适用范围&quot;&gt;&lt;/a&gt;适用范围&lt;/h2&gt;&lt;p&gt;可以使用整体二分解决的题目需要满足以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;询问的答案具</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="整体二分" scheme="https://krt.moe/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>P4732 题解</title>
    <link href="https://krt.moe/posts/P4732/"/>
    <id>https://krt.moe/posts/P4732/</id>
    <published>2023-07-09T16:00:00.000Z</published>
    <updated>2024-07-31T14:59:21.632Z</updated>
    
    <content type="html"><![CDATA[<p>“这样的我会被谁拯救吗　你发现了吧” —— 《月光掌》</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设第 $i$ 次撤销操作要撤销的是 $j$，那么 $i$ 到 $j$ 的操作中不存在优先级比 $j$ 小的，所以 $j$ 到 $i$ 的操作不会在没撤销 $i$ 的情况下被撤销。</p><p>考虑可持久化线段树，维护操作的优先级，撤销操作 $i$ 直接继承 $j-1$ 的线段树，查询 $j$ 直接线段树上二分。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="type">int</span> l,r,v;&#125; tr[N*<span class="number">30</span>];</span><br><span class="line">        <span class="type">int</span> root[N],idx;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;tr[u].v = <span class="built_in">min</span>(tr[tr[u].l].v,tr[tr[u].r].v);&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">segtree</span>()&#123;tr[<span class="number">0</span>].v=<span class="number">1e9</span>;&#125;</span><br><span class="line">        <span class="type">int</span>&amp; <span class="keyword">operator</span> [](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> root[x];&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">            tr[++idx] = tr[u];</span><br><span class="line">            u = idx;</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                tr[u].v = v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;=mid)</span><br><span class="line">                <span class="built_in">modify</span>(tr[u].l,l,mid,p,v);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">modify</span>(tr[u].r,mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l==r)</span><br><span class="line">                <span class="keyword">return</span> l;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[u].r||tr[tr[u].r].v&gt;=p)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].l,l,mid,p);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].r,mid+<span class="number">1</span>,r,p);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = in;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="type">int</span> x = in;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            tr[k] = tr[k<span class="number">-1</span>];</span><br><span class="line">            ans[k] = x;</span><br><span class="line">            tr.<span class="built_in">modify</span>(tr[k],<span class="number">1</span>,n,k,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> p = tr.<span class="built_in">query</span>(tr[k<span class="number">-1</span>],<span class="number">1</span>,n,-x);</span><br><span class="line">            tr[k] = tr[p<span class="number">-1</span>];</span><br><span class="line">            ans[k] = ans[p<span class="number">-1</span>];</span><br><span class="line">            tr.<span class="built_in">modify</span>(tr[k],<span class="number">1</span>,n,k,-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">out</span>(ans[k],<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“这样的我会被谁拯救吗　你发现了吧” —— 《月光掌》&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;设第 $i$ 次撤销操作要撤销的是 $j$，那么 $i$ 到 $j$ </summary>
      
    
    
    
    
    <category term="题解笔记" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
    <category term="可持久化线段树" scheme="https://krt.moe/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>网络流常见建模</title>
    <link href="https://krt.moe/posts/joi2015ho_d/"/>
    <id>https://krt.moe/posts/joi2015ho_d/</id>
    <published>2023-07-03T16:00:00.000Z</published>
    <updated>2024-07-31T14:46:40.938Z</updated>
    
    <content type="html"><![CDATA[<p>你眼中倒映的世界 一瞬永远 —— 《梦语》</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先答案有单调性，考虑二分。</p><p>然后每次留下来的构成一颗三叉树，父亲是儿子的中位数，考虑树形 dp。</p><p>上很经典的中位数套路，设二分的值为 $v$，$\geq v$ 的 $g_v$ 为 $1$，$&lt; v$ 的 $g_v$为 $-1$。</p><p>如果儿子的值之和 $&gt;0$ 那么父亲就 $\geq v$。</p><p>考虑设 $f_u$ 为 $g_u &gt; 0$ 时最小的子树的叶子中 $\geq v$ 的个数。</p><p>转移为 $f_u &#x3D; \sum f_v -\max f_v$，因为如果 $g_u &gt; 0$ 必须有两个及以上的 $g_v&#x3D;1$，多了没用所以是选择最小的的两个 $f_v$。</p><p>如果 $f_{root} \leq$ 序列中 $\leq v$ 的个数就是可行的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="type">int</span> d[N],p[N],f[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        f[u] += f[v];</span><br><span class="line">        maxx = <span class="built_in">max</span>(maxx,f[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u] -= maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=root;k++)</span><br><span class="line">        f[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[k])</span><br><span class="line">            f[k] = d[p[k]]&gt;=v?<span class="number">0</span>:N+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[k] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=m+<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        cnt += d[k]&gt;=v;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> f[root]&lt;=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = in,m = in;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        q.<span class="built_in">push</span>(k);</span><br><span class="line">    root = n;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> c = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        root++;</span><br><span class="line">        g[root].<span class="built_in">push_back</span>(a);</span><br><span class="line">        g[root].<span class="built_in">push_back</span>(b);</span><br><span class="line">        g[root].<span class="built_in">push_back</span>(c);</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">        d[k] = in,p[(<span class="type">int</span>)in] = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=m+<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        d[k] = in;</span><br><span class="line">    <span class="type">int</span> L = <span class="number">1</span>,R = <span class="number">1000000000</span>,ans;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            L = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">out</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你眼中倒映的世界 一瞬永远 —— 《梦语》&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;首先答案有单调性，考虑二分。&lt;/p&gt;
&lt;p&gt;然后每次留下来的构成一颗三叉树，父亲是</summary>
      
    
    
    
    
    <category term="题解" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://krt.moe/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>网络流常见建模</title>
    <link href="https://krt.moe/posts/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E8%A7%81%E5%BB%BA%E6%A8%A1/"/>
    <id>https://krt.moe/posts/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E8%A7%81%E5%BB%BA%E6%A8%A1/</id>
    <published>2023-06-29T16:00:00.000Z</published>
    <updated>2024-07-31T14:59:21.627Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲建图方法，定义和证明内容较少。</p><p>正好网络流二十四题做完了整理下。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>网络流模型<ul><li>最大流最小割<ul><li>最小割树</li><li>平面图最小割</li></ul></li><li>费用流<ul><li>SSP 算法</li><li>有负圈的费用流</li></ul></li><li>上下界建模<ul><li>无源汇上下界可行流</li><li>有源汇上下界可行流</li><li>有源汇上下界最大&#x2F;小流</li></ul></li></ul></li><li>经典问题<ul><li>二分图<ul><li>二分图最大匹配</li><li>二分图最小点覆盖</li><li>二分图最大独立集</li></ul></li><li>路径覆盖与链覆盖<ul><li>DAG 最小路径覆盖</li><li>DAG 最小链覆盖</li><li>DAG 最长反链</li></ul></li><li>最大权闭合子图</li><li>最大密度子图</li></ul></li><li>各种建模<ul><li>拆点</li><li>分层图</li><li>最大流相关</li><li>最小割相关<ul><li>最小割离散变量模型（切糕）</li></ul></li><li>费用流相关</li><li>杂<ul><li>区间问题常见建模</li></ul></li></ul></li></ul><h1 id="网络流模型"><a href="#网络流模型" class="headerlink" title="网络流模型"></a>网络流模型</h1><h2 id="最大流最小割"><a href="#最大流最小割" class="headerlink" title="最大流最小割"></a>最大流最小割</h2><p>最大流 &#x3D; 最小割是网络流中的重要结论，运用最大流和最小割可以解决一些复杂度划分问题。</p><h3 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h3><p>主要解决 <strong>多次询问</strong> 无向图两点之间的最小割的问题。</p><p>一个 $N$ 个点的图上，两点之间只有 $N$ 中本质不同的最小割。因此一定存在一棵树，满足树上两点的最小割等于原图上两点的最小割。我们把这样的树称之为 __最小割树__。</p><h4 id="Gomory-Hu-算法"><a href="#Gomory-Hu-算法" class="headerlink" title="Gomory-Hu 算法"></a>Gomory-Hu 算法</h4><p>考虑分治，在所有点中任取两个作为源汇点求出最小割，划分成两个互不连通的割集。对这两个点连边，边权为求出来的最小割。然后对与两个割集递归下去做。同时每次的最小割都是对于全局跑的，</p><p>询问两个点之间的最小割，就是求这两个点在最小割树上的路径中最小的边。可以用倍增实现。</p><h4 id="参考-例题"><a href="#参考-例题" class="headerlink" title="参考&amp;例题"></a>参考&amp;例题</h4><p><a href="https://www.luogu.com.cn/problem/P4897">P4897【模板】最小割树</a></p><p><a href="https://www.luogu.com.cn/blog/Eznibuil/solution-p4897">证明见 Eznibuil 博客</a></p><h3 id="平面图最小割"><a href="#平面图最小割" class="headerlink" title="平面图最小割"></a>平面图最小割</h3><p>平面图最小割 &#x3D; 对偶图最短路。</p><h4 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h4><p>如果图 $G$ 能画在平面 $S$ 上，且除顶点外无边相交，则称 $G$ 可平面嵌入 $S$，$G$ 可称为可平面图或平面图，画出的没有边相交的图称为 $G$ 的平面表示或平面嵌入。</p><h4 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h4><p>设 $G$ 是平面图的某一个平面嵌入，构造图 $G^*$：</p><ol><li>在 $G$ 的每个面放 $R_i$ 置 $G^*$ 的一个顶点 $v^*$。</li><li>设 $e$ 为 $G$ 的一条边，若 $e$ 在 $G$ 的面 $R_i$ 和 $R_j$ 的公共边上，做 $G^*$ 的边 $e^*$ 与 $e$ 相交，且 $e^*$ 连接 $G^*$ 的顶点 $v_i^*,v_j^*$，即 $e^*&#x3D;(v_i^*,v_j^*)$，$e^*$ 不与其他边相交。若 $e$ 为 $G$ 中的桥且在 $R_i$ 的边界上，则 $e^*$ 是以 $R_i$ 中顶点 $v_i^*$ 为端点的环，即 $e^*&#x3D;(v_i^*,v_j^*)$。</li></ol><p>形象化的说，对偶图就是把平面图的每条边 __旋转了 $90$ 度__。</p><h4 id="对偶图的性质"><a href="#对偶图的性质" class="headerlink" title="对偶图的性质"></a>对偶图的性质</h4><ol><li>$G^*$ 为平面图，且为平面嵌入。</li><li>$G$ 中自环对应 $G^*$ 桥，$G$ 中桥对应 $G^*$ 自环。</li><li>$G^*$ 是连通的。</li><li>若 $G$ 的面 $R_i,R_j$ 的边界上至少有两条公共边，则关联<br>$v_i^*,v_j^*$ 的边有平行边，$G^*$ 多半是多重图。</li><li>同构的图的对偶图不一定是同构的。</li><li>$G^{**}$ 与 $G$ 同构当且仅当 $G$ 是连通图。</li><li>平面图最小割 &#x3D; 对偶图最短路</li></ol><h4 id="参考-例题-1"><a href="#参考-例题-1" class="headerlink" title="参考&amp;例题"></a>参考&amp;例题</h4><p><a href="https://www.luogu.com.cn/problem/P2046">P2046 [NOI2010] 海拔</a></p><p><a href="https://oi-wiki.org/graph/planar/">oi-wiki</a></p><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><p>可以解决一些需要最优化的问题。</p><h3 id="SSP-算法"><a href="#SSP-算法" class="headerlink" title="SSP 算法"></a>SSP 算法</h3><p>每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p><p>如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。</p><p>设该网络的最大流为 $f$ ，则最坏时间复杂度为 $O(nmf)$。SSP 算法是 <strong>伪多项式时间</strong> 的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。</p><h4 id="参考-例题-2"><a href="#参考-例题-2" class="headerlink" title="参考&amp;例题"></a>参考&amp;例题</h4><p><a href="https://www.luogu.com.cn/problem/P3381">P7173【模板】最小费用最大流 </a></p><p><a href="https://oi-wiki.org/graph/flow/min-cost/">oi-wiki</a></p><h3 id="有负圈的费用流"><a href="#有负圈的费用流" class="headerlink" title="有负圈的费用流"></a>有负圈的费用流</h3><p>由于存在最短路，所以费用流算法不能直接做费用有负圈的图。</p><p>消圈算法本身就有消除负圈的过程，但是效率低下。</p><p>对于网络中的负费用边 $(x,y)$，强制满流。然后加入 $(y,x)$，费用为原来费用的相反数，用于退流。</p><p>跑有源汇上下界最小费用最大流即可。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/P7173">P7173 【模板】有负圈的费用流</a></p><h2 id="上下界建模"><a href="#上下界建模" class="headerlink" title="上下界建模"></a>上下界建模</h2><p>上下界网络流本质是给流量网络的每一条边设置了流量上界 $c(u,v)$ 和流量下界 $b(u,v)$ 。也就是说，一种可行的流必须满足 $b(u,v) \leq f(u,v) \leq c(u,v)$ 。同时必须满足除了源点和汇点之外的其余点流量平衡。</p><h3 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h3><p>先假设每条边已经流了 $b(u,v)$ 的流量，在新图中加入流量为 $c(u,v)-b(u,v)$ 的边。</p><p>最大流需要满足初始流量平衡条件，但是构造出来的初始流很有可能不满足初始流量平衡。</p><p>假设一个点初始流入流量减初始流出流量为 $M$，同时建立附加源点 $S’$ 和附加汇点 $T’$：</p><ul><li>$M&#x3D;0$ 流量平衡</li><li>$M&gt;0$ 入流量大，$S$ 向其连流量为 $M$ 的边</li><li>$M&lt;0$ 出流量大，其向 $T$ 连流量为 $-M$ 的边</li></ul><p>如果附加边满流，说明这一个点的流量平衡条件可以满足，否则这个点的流量平衡条件不满足。</p><p>在建图完毕之后跑 $S’$ 到 $T’$ 的最大流，若 $S’$ 连出去的边全部满流，则存在可行流，否则不存在。</p><h3 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h3><p>设源点为 $s$，汇点为 $t$。添加一条 $t$ 到 $s$ 的上界为 $\infty$ 下界为 $0$ 的边。</p><p>注意这里的源汇点已被视为普通点，与超级源汇点不同的。</p><h3 id="有源汇上下界最大-小流"><a href="#有源汇上下界最大-小流" class="headerlink" title="有源汇上下界最大&#x2F;小流"></a>有源汇上下界最大&#x2F;小流</h3><h4 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h4><p>先找到可行流，然后删去附加边 $t \rightarrow s$，在残留网络上跑最大流。</p><p>将可行流流量和最大流流量相加即为答案。</p><h4 id="最小流"><a href="#最小流" class="headerlink" title="最小流"></a>最小流</h4><p>先在没加附加边的网络上跑最大流，再对残量网络加入附加边 $t \rightarrow s$，最小流即为附加边的流量。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ul><li>最大流：<a href="https://www.luogu.com.cn/problem/P5192">P5192 Zoj3229 Shoot the Bullet|东方文花帖|【模板】有源汇上下界最大流 </a></li><li>最小流：<a href="https://www.luogu.com.cn/problem/P4843">P4843 清理雪道</a></li></ul><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h3><p>将源点连上左边所有点，右边所有点连上汇点，容量dou为 $1$。原来的每条边从左往右连边，容量也皆为 $1$，最大流即最大匹配。</p><p>如果用 <code>Dinic</code> 算法求最大流，时间复杂度为 $\sqrt{n}m$。</p><h3 id="二分图最小点覆盖"><a href="#二分图最小点覆盖" class="headerlink" title="二分图最小点覆盖"></a>二分图最小点覆盖</h3><blockquote><p>最小点覆盖：选最少的点，满足每条边至少有一个端点被选。</p></blockquote><p>König 定理：最小点覆盖 $&#x3D;$ 最大匹配。</p><h3 id="二分图最大独立集"><a href="#二分图最大独立集" class="headerlink" title="二分图最大独立集"></a>二分图最大独立集</h3><blockquote><p>最大独立集：选最多的点，满足两两之间没有边相连。</p></blockquote><p>二分图中，最大独立集 $&#x3D;n\ -$ 最小点覆盖。</p><p>因为在最小点覆盖中，任意一条边都被至少选了一个顶点，所以对于其点集的补集，任意一条边都被至多选了一个顶点，所以不存在边连接两个点集中的点，且该点集最大。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://oi-wiki.org/graph/graph-matching/bigraph-weight-match/">oiwiki</a></p><h2 id="路径覆盖与链覆盖"><a href="#路径覆盖与链覆盖" class="headerlink" title="路径覆盖与链覆盖"></a>路径覆盖与链覆盖</h2><h3 id="DAG-最小路径覆盖"><a href="#DAG-最小路径覆盖" class="headerlink" title="DAG 最小路径覆盖"></a>DAG 最小路径覆盖</h3><blockquote><p>DAG 最小路径覆盖：尽可能少的不相交的路径（链）覆盖掉所有节点。</p></blockquote><p>考虑把单个结点也看成一条路径，相邻结点合并路径条数就会减少，所以要最大化可以合并的个数。</p><p>因为是最大化合并，考虑 <strong>二分图最大匹配</strong> ，把每个点拆成 $u’$ 和 $u’’$，原图上边 $u \rightarrow v$ 就在新图上连一条 $u’ \rightarrow v’’$，跑二分图最大匹配，就是最大的可合并的点数，总点数减去大的可合并的点数就是最小路径覆盖。</p><h3 id="DAG-最小链覆盖"><a href="#DAG-最小链覆盖" class="headerlink" title="DAG 最小链覆盖"></a>DAG 最小链覆盖</h3><blockquote><p>DAG 最小链覆盖：尽可能少的的路径（链）覆盖掉所有节点，可以相交。</p></blockquote><p>最小链覆盖与最小路径覆盖非常相近，考虑将最小链覆盖转化为最小路径覆盖。</p><p>用 <code>Floyd</code> 求出原图的传递闭包，直接在传递闭包上跑最小路径覆盖即可。</p><blockquote><p>传递闭包：这里简单理解为对于所有联通的点对连边的新图</p></blockquote><h3 id="DAG-最长反链"><a href="#DAG-最长反链" class="headerlink" title="DAG 最长反链"></a>DAG 最长反链</h3><blockquote><p>反链：点的集合满足任意 $x,y$，$x,y$ 互不连通</p></blockquote><p>Dilworth 定理：最小链覆盖大小 $&#x3D;$ 最长反链长度。</p><h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><blockquote><p>闭合子图：对于点集 $S$，任意 $u\in S$，$u$ 的出边的另一个点也属于 $S$。</p></blockquote><blockquote><p>最大权闭合子图：点权和最大的闭合子图。</p></blockquote><p>最大权闭合子图 $&#x3D;$ 正权和 $-$ 最小割</p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/P2762">P2762 太空飞行计划问题 </a></p><p><a href="https://www.luogu.com.cn/problem/P3410">P3410 拍照</a></p><h2 id="最大密度子图"><a href="#最大密度子图" class="headerlink" title="最大密度子图"></a>最大密度子图</h2><blockquote><p>最大密度子图：闭合子图使得 $\frac{|E|}{|V|}$ 最大。</p></blockquote><p>一般情况下，我们使用 <strong>01 分数规划</strong> 解决最大密度子图问题。</p><p>二分比值 $v$，建图</p><ul><li>$S$ 到 $i$ 连容量为 $m$ 的边</li><li>$i$ 到 $T$ 连容量为 $m+2*v-deg_i$ 的边</li><li>原图上的边容量为 $1$</li></ul><p>如果流量 $&#x3D;n\times m$ 就存在密度为 $\geq v$ 的子图。</p><p>一般来说二分的 $eps$ 不能设太小，不然无法判断边是否有流量。</p><h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/UVA1389">UVA1389 Hard Life</a></p><h2 id="各种建模"><a href="#各种建模" class="headerlink" title="各种建模"></a>各种建模</h2><h3 id="拆点"><a href="#拆点" class="headerlink" title="拆点"></a>拆点</h3><p>本质上是将点的限制转化为边的限制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要讲建图方法，定义和证明内容较少。&lt;/p&gt;
&lt;p&gt;正好网络流二十四题做完了整理下。&lt;/p&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;网络流模型&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="网络流" scheme="https://krt.moe/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="学习笔记笔记" scheme="https://krt.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>APIO2023 赛博乐园</title>
    <link href="https://krt.moe/posts/APIO2023/"/>
    <id>https://krt.moe/posts/APIO2023/</id>
    <published>2023-05-26T16:00:00.000Z</published>
    <updated>2024-07-31T14:59:21.628Z</updated>
    
    <content type="html"><![CDATA[<p>“并没有 不一样 为何感到悲伤”   —— 《尘降》</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先把图反着跑，这样总通行时间除以 $2$ 就变成了后续时间都除以 $2$，当前总通过时间为 $0$ 就变成了后续时间都为 $0$。</p><p>然后把一个点拆开成 $K+2$ 个，第 $i$ 个代表经过 $i$ 次除以二操作的点，最后一个代表经过清零操作的点，然后跑最短路。</p><p>注意一下 $H$ 不能多次经过和不能达到为 $-1$，这样就有 $97$ 分了。</p><p>发现除以二操作做 $\log_2 \frac{10^5\times10^9}{10^{-6}}$ 次就会变成可以忽略的值，所以 $K$ 和 $70$ 取小的那一个就行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>,C = <span class="number">72</span>,L = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; LDII;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; g[N];</span><br><span class="line"><span class="type">double</span> dis[N][C];<span class="comment">//清零和超过 L 次除以 2 视为一致</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K, <span class="type">int</span> H, std::vector&lt;<span class="type">int</span>&gt; x, std::vector&lt;<span class="type">int</span>&gt; y, std::vector&lt;<span class="type">int</span>&gt; c, std::vector&lt;<span class="type">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;N;k++)&#123;</span><br><span class="line">        g[k].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=L;j++)</span><br><span class="line">            dis[k][j] = <span class="number">2e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;M;k++)&#123;</span><br><span class="line">        g[x[k]].<span class="built_in">emplace_back</span>(y[k],c[k]);</span><br><span class="line">        g[y[k]].<span class="built_in">emplace_back</span>(x[k],c[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;LDII,vector&lt;LDII&gt;,greater&lt;LDII&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,&#123;H,<span class="number">0</span>&#125;&#125;);</span><br><span class="line">    dis[H][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [u,k] = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>[v,w]:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==H)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=L)&#123;<span class="comment">//视作清零操作</span></span><br><span class="line">                <span class="keyword">if</span>(dis[v][L]&gt;dis[u][k])&#123;</span><br><span class="line">                    dis[v][L] = dis[u][k];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dis[v][L],&#123;v,L&#125;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v][L]&gt;dis[u][k]+w*<span class="number">1.0</span>/(<span class="number">1ll</span>&lt;&lt;k))&#123;</span><br><span class="line">                    dis[v][L] = dis[u][k]+w*<span class="number">1.0</span>/(<span class="number">1ll</span>&lt;&lt;k);</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dis[v][L],&#123;v,L&#125;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[v]==<span class="number">2</span>&amp;&amp;k&lt;K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v][k+<span class="number">1</span>]&gt;dis[u][k]+w*<span class="number">1.0</span>/(<span class="number">1ll</span>&lt;&lt;k))&#123;</span><br><span class="line">                    dis[v][k+<span class="number">1</span>] = dis[u][k]+w*<span class="number">1.0</span>/(<span class="number">1ll</span>&lt;&lt;k);</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dis[v][k+<span class="number">1</span>],&#123;v,k+<span class="number">1</span>&#125;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[v][k]&gt;dis[u][k]+w*<span class="number">1.0</span>/(<span class="number">1ll</span>&lt;&lt;k))&#123;</span><br><span class="line">                dis[v][k] = dis[u][k]+w*<span class="number">1.0</span>/(<span class="number">1ll</span>&lt;&lt;k);</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v][k],&#123;v,k&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=L;k++)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,dis[<span class="number">0</span>][k]);</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;<span class="number">1e18</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>考试的时候用的是 $50$ 过了，死过以内。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“并没有 不一样 为何感到悲伤”   —— 《尘降》&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;首先把图反着跑，这样总通行时间除以 $2$ 就变成了后续时间都除以 $2</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最短路" scheme="https://krt.moe/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>ABC241G 题解</title>
    <link href="https://krt.moe/posts/AT_abc241_g/"/>
    <id>https://krt.moe/posts/AT_abc241_g/</id>
    <published>2023-05-23T16:00:00.000Z</published>
    <updated>2024-07-31T14:59:21.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>枚举第一名，假设以后的比赛该名玩家都获胜，然后判定是否合法。</p><p>数据范围很网络流，考虑最大流，流量代表得分，然后是建图：</p><ul><li>源点和每场比赛连容量为 $1$ 的边</li><li>比赛如果有胜负就向胜者连边，否则就向参与比赛的两个人连边</li><li>设第一名的得分为 $w$，第一名向汇点连容量为 $w$ 的边，其余的人得分不能超过第一名，所以其余的人向汇点连容量为 $w-1$ 的边</li></ul><p>由于总场次为 $\frac{n(n+1)}{2}$，如果最大流为 $\frac{n(n+1)}{2}$ 就说明每场比赛都分出了胜负，这种情况合法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3000</span>,M = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> h[N],ne[M],e[M],w[M],idx;</span><br><span class="line"><span class="type">int</span> win[N][N];</span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    w[idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">    w[idx] = <span class="number">0</span>,e[idx] = a,ne[idx] = h[b],h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">    <span class="type">int</span> q[N],d[N],cur[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">        d[S] = <span class="number">0</span>,cur[S] = h[S];</span><br><span class="line">        q[++tt] = S;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line">            <span class="type">int</span> u = q[hh++];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=h[u];~k;k=ne[k])&#123;</span><br><span class="line">                <span class="type">int</span> v = e[k];</span><br><span class="line">                <span class="keyword">if</span>(d[v]==<span class="number">-1</span>&amp;&amp;w[k])&#123;</span><br><span class="line">                    d[v] = d[u]+<span class="number">1</span>;</span><br><span class="line">                    cur[v] = h[v];</span><br><span class="line">                    <span class="keyword">if</span>(v==T)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    q[++tt] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==T)</span><br><span class="line">            <span class="keyword">return</span> lim;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=cur[u];~k&amp;&amp;flow&lt;lim;k=ne[k])&#123;</span><br><span class="line">            cur[u] = k;</span><br><span class="line">            <span class="type">int</span> v = e[k];</span><br><span class="line">            <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span>&amp;&amp;w[k])&#123;</span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">find</span>(v,<span class="built_in">min</span>(w[k],lim-flow));</span><br><span class="line">                <span class="keyword">if</span>(!t)</span><br><span class="line">                    d[v] = <span class="number">-1</span>;</span><br><span class="line">                w[k] -= t;</span><br><span class="line">                w[k^<span class="number">1</span>] += t;</span><br><span class="line">                flow += t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>,flow;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">            <span class="keyword">if</span>((flow=<span class="built_in">find</span>(S,<span class="number">1e9</span>)))</span><br><span class="line">                r += flow;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">in</span>(),m = <span class="built_in">in</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">in</span>(),b = <span class="built_in">in</span>();</span><br><span class="line">        win[a][b] = <span class="number">1</span>;</span><br><span class="line">        win[b][a] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S = <span class="number">0</span>,T = n+n*(n<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = n,wnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=j+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="built_in">add</span>(S,++cnt,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(win[i][j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(win[j][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==k)</span><br><span class="line">                            wnt++;</span><br><span class="line">                        <span class="built_in">add</span>(S,j,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==k)</span><br><span class="line">                            wnt++;</span><br><span class="line">                        <span class="built_in">add</span>(S,i,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==k||i==k)&#123;</span><br><span class="line">                        <span class="built_in">add</span>(cnt,k,<span class="number">1</span>);</span><br><span class="line">                        wnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">add</span>(cnt,j,<span class="number">1</span>);</span><br><span class="line">                        <span class="built_in">add</span>(cnt,i,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(j==k)</span><br><span class="line">                <span class="built_in">add</span>(j,T,wnt);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(j,T,wnt<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(Dinic::<span class="built_in">dinic</span>()==n*(n<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">out</span>(k,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;枚举第一名，假设以后的比赛该名玩家都获胜，然后判定是否合法。&lt;/p&gt;
&lt;p&gt;数据范围很网络流，考虑最大流，流量代表得分，然后是建图：&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
    <category term="网络流" scheme="https://krt.moe/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="最大流" scheme="https://krt.moe/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>APIO2023 线上游记</title>
    <link href="https://krt.moe/posts/P4698/"/>
    <id>https://krt.moe/posts/P4698/</id>
    <published>2023-05-23T16:00:00.000Z</published>
    <updated>2024-07-31T14:59:21.628Z</updated>
    
    <content type="html"><![CDATA[<p>“请告诉我为何心不停的跳动　这颗心究竟装着什么” —— 《人偶之梦》</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到 $p_i&lt;p_j$ 则 $c_i\leq c_j$，存在偏序关系。</p><p>一个贪心的想法是，按照订单的 $v$ 从大到小，每次找到大于 $d$ 的最小的 $p$ 住进去。</p><p>但是如果房间已经被占用，就住进大于 $d$ 的 $p$ 最小的没有被占用的房间，而不是把占用清除。</p><p>考虑这样为什么是对的，设占用房间的为 $i$，要住进去的为 $j$。</p><ul><li>如果 $i,j$ 都要入住，答案无影响。</li><li>如果 $i,j$ 只有一个要入住，因为 $v_i&gt;v_j$，所以 $i$ 肯定比 $j$ 更优，$j$ 必定不会被选到（就选选的不是最优的房间也不影响）。</li></ul><p>现在问题变成了，找到大于 $d$ 的 $p$ 最小的没有被占用的房间，然后把这个房间删除，<code>multiset</code> 可以解决（注意房间可重，<code>set</code> 不可重）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; house;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; order;</span><br><span class="line"><span class="type">int</span> n,m,o;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">in</span>(),m = <span class="built_in">in</span>(),o = <span class="built_in">in</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="built_in">in</span>(),p = <span class="built_in">in</span>();</span><br><span class="line">        house.<span class="built_in">insert</span>(&#123;p,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    order.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,d]:order)</span><br><span class="line">        v = <span class="built_in">in</span>(),d = <span class="built_in">in</span>();</span><br><span class="line">    <span class="built_in">sort</span>(order.<span class="built_in">begin</span>(),order.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> a,<span class="keyword">auto</span> b)&#123;<span class="keyword">return</span> a.first!=b.first?a.first&gt;b.first:a.second&lt;b.second;&#125;);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,d]:order)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = house.<span class="built_in">lower_bound</span>(&#123;d,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(it!=house.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(v&lt;=(*it).second)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v-(*it).second);</span><br><span class="line">            house.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),greater&lt;&gt;());</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">min</span>(o,(<span class="type">int</span>)res.<span class="built_in">size</span>());k++)</span><br><span class="line">        ans += res[k];</span><br><span class="line">    <span class="built_in">out</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>$p_i&lt;p_j$ 则 $c_i\leq c_j$ 放在题面更合理吧，放在数据范围有点抽象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“请告诉我为何心不停的跳动　这颗心究竟装着什么” —— 《人偶之梦》&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;注意到 $p_i&amp;lt;p_j$ 则 $c_i&#92;leq </summary>
      
    
    
    
    
    <category term="题解笔记" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>APIO2023 线上游记</title>
    <link href="https://krt.moe/posts/apio2023%E7%BA%BF%E4%B8%8A%E6%B8%B8%E8%AE%B0/"/>
    <id>https://krt.moe/posts/apio2023%E7%BA%BF%E4%B8%8A%E6%B8%B8%E8%AE%B0/</id>
    <published>2023-05-22T16:00:00.000Z</published>
    <updated>2024-07-31T14:31:43.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="day"><a href="#day" class="headerlink" title="day-?"></a>day-?</h2><p>报名被报成线上了，寄寄寄。</p><h2 id="day-1"><a href="#day-1" class="headerlink" title="day-?"></a>day-?</h2><p>P 和我的年龄给了我可能今年唯一能看的成绩。</p><h2 id="day-0"><a href="#day-0" class="headerlink" title="day 0"></a>day 0</h2><p>麦会炸，是那种嘶吼声的回音的感觉。</p><p>字符串，感觉自己没学过了。</p><p>直播能很好看到旷课人数，很震撼，签到更震撼。</p><p>同时知道了 __线上没监考__。</p><p>线下看起来好好玩，你们发在 LA 群里的自拍是在同情我吗，你们玩音游的真多，我也想玩，你们发在 LA 里的 kfc 是在同情我吗，华山饭店好厉害，你们带带我行不。</p><p>然后一遍听中v曲一边改之前 apio 的题，自信啊，那不得保底 Ag。</p><h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><p>T1 板到不行，半小时就写好了。</p><p>这是什么，cms，刷新一下。</p><p>这是什么，OJ，交一下。</p><p>啥情况就不说了，结束前半小时才知道我 T1 过了（一个小时 debug 一次），我 K 和 50 取 min 还能过很厉害啊，想不通。</p><p>T2 不会，32 分不说了，$a_i\leq 3$ 的随便搞几下就过了（当然也是在考试后知道的）。$7$ 分的暴力写挂了（同上）。</p><p>T3 电路，可是我去的 P，加法器没写出来。</p><p>能不能下次复刻光追，求求你了。</p><p>结束了。</p><h2 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h2><p>听到了 200 一车，早就知道了，我考的相当烂，我无法改变。</p><p>晚上在阳台吹了一晚上风。</p><p>以为自己打铁打的，结果线上 Ag 了（那 $7$ 分挺可惜的，不然线上 Au 了）。</p><p>一看线下 Cu 130，别的不评价了，没资格评价。</p><p>闭幕式之后的表演环节没直播，但是知道了好玩的事。</p><p>上半年这就是最后一场比赛的，本来说能买个 D 的，结果感觉我穿越到平行世界了。</p><p>结束了，感觉最近精神状态一直不太好，空落落的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;day&quot;&gt;&lt;a href=&quot;#day&quot; class=&quot;headerlink&quot; title=&quot;day-?&quot;&gt;&lt;/a&gt;day-?&lt;/h2&gt;&lt;p&gt;报名被报成线上了，寄寄寄。&lt;/p&gt;
&lt;h2 id=&quot;day-1&quot;&gt;&lt;a href=&quot;#day-1&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="游记" scheme="https://krt.moe/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ABC299G 题解</title>
    <link href="https://krt.moe/posts/AT_abc299_g/"/>
    <id>https://krt.moe/posts/AT_abc299_g/</id>
    <published>2023-04-24T16:00:00.000Z</published>
    <updated>2024-07-31T14:46:47.233Z</updated>
    
    <content type="html"><![CDATA[<p>“まだ動くまだ進む 物語の上を泳げ” —— 《スイマー》</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>维护一个栈，每次加入一个值。</p><p>如果栈顶在之后也会出现并且比加入的值大就弹出。</p><p>这样使得每个值尽可能放在前面。</p><p>粗略的证明一下。假设有两个序列 $A,B$，$A$ 的字典序小于 $B$，且 $A$ 是字典序最小的。</p><p>$A$ 的第一个与 $B$ 不同的位置为 $x$，$A_x$ 在 $B$ 中出现的位置 $y$ 一定在 $x$ 之后。</p><p>$B_y$ 能移动到 $x$，在处理 $B$ 的时候 $B_y$ 会被移动到 $x$，所以不会找到 $B$ 序列。</p><p>那么找到的序列是字典序最小的。</p><p>不过一个排列的置换字典序最小不一定代表这个排列的字典序最小。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="type">int</span> a[N],pos[N];</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="type">bool</span> b[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        cin &gt;&gt; a[k];</span><br><span class="line">        pos[a[k]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[a[k]])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;stk[top]&gt;a[k]&amp;&amp;pos[stk[top]]&gt;k)&#123;</span><br><span class="line">            b[stk[top]] = <span class="literal">false</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = a[k];</span><br><span class="line">        b[a[k]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">        cout &lt;&lt; stk[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“まだ動くまだ進む 物語の上を泳げ” —— 《スイマー》&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;维护一个栈，每次加入一个值。&lt;/p&gt;
&lt;p&gt;如果栈顶在之后也会出现并</summary>
      
    
    
    
    
    <category term="题解" scheme="https://krt.moe/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://krt.moe/tags/atcoder/"/>
    
  </entry>
  
</feed>
